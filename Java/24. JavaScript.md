# 24. JavaScript
- prefile
	- JavaScript是一种可以与HTML混合使用的脚本语言, 其编写的程序可以直接在浏览器中解释执行
	- js的国际标准是ECMAScript
	- js是基于对象的语言, 但不是面向对象的语言(js中万物皆对象)
	- js使用弱变量类型(变量没有类型, 但是数据有类型)
	- js大小写敏感
	- js代码可以不加分号
- 注释
	- 单行注释: `//`
	- 多行注释: `/**/`
- 变量
	- js中所有变量的声明都使用关键字var
	- js可以声明同名变量, 后声明的变量会将前面的覆盖
	- 数据类型
		- number
			- js中没有整型和浮点型之分
		- string
			- js中只有字符串, 使用字符串时可以使用单引号和双引号, 二者没有区分
		- boolean
		- object
		- null
			- null其实是一个对象
		- NaN
			- NaN是number类型
		- undefine
			- 变量在声明后没有初始化时的类型是undefined, 值也是undefined
		- 数据类型判断关键字: typeof
			- 一个没有被声明的变量也可以被typeof, 但是不能使用
	- 类型转换
		- 显示转换
			- Number()方法: 将能够转换为number类型的数据转为number, 不能转换的将其转为NaN
				- 若是Date对象则为时间戳(ms)
			- Boolean()方法: 将数据转为boolean, 有值为true, 无值为false
		- 隐式转换
			- 在if()中, 不是boolean的数据将隐式转为boolean
			- 在算数运算中, js会将不是number类型的数据转为number(除非碰到字符串连接符)
			- 当算数运算中出现对象时, js会自动调用valueOf方法(字符串连接符为toString)
- 运算符
	- 算数运算符: +  -  *  /  %  ++  --
	- 字符串连接符: +
	- 逻辑运算: &&  ||  !  &(按位与)  |(按位或)
	- 赋值运算符: =  +=  *=  ...
	- 关系运算符: >  >=  <  <=  !=  ==  ===
		- ==: 当==两边的数据类型不一致时, js会将两边都转为number类型进行比较(两边都是对象时, 比的是地址)
		- ===: 当===两边类型不一致时, 为false, 类型一致再比较类型, 一致返回true
		- 特例: null==undefined时为true, 但是Number(null)==Number(undefined)为false
- 程序结构
	- 顺序结构
	- 分支结构
		- if...else if...else
		- switch() case...default...
			- switch的判断是===
	- 循环结构
		- for
			- 普通for循环
			- 增强for循环: `for (var i in arr){arr[i]}	//注意js中的增强for循环取的是角标`
		- while
		- do...while
- 数组
	- 数组的声明
		1. var arr = new Array();	//构造器里面可以添加参数, 指定数组的初始大小或指定初始元素
			- var arr = new Array(5);
			- var arr = new Array([5]);
		2. var arr = [1, "hello wolrd"]
	- 数组的length属性
		- length可以查看数组当前的长度
		- 还可以直接给length赋值, 达到改变数组长度的目的
	- Array的方法
		- concat
			- 类似于Java的append
			- 注意当参数中出现数组, 这个数组会被自动解包
		- join
			- 将数组的元素以给定的连接符号连接成一个字符串
			- 如: `[1, 2, 3].join("-")`得到`"1-2-3"`
		- pop
			- 移除数组的最后一个元素, 并返回
		- push
			- 将一个新元素放入数组中, 并返回新数组的长度
			- 注意push的元素如果是一个数组, 则会将其作为一个元素放入(数组的嵌套)
		- shift
			- 移除数组的第一个元素, 并返回
		- unshift
			-将一个新元素放入数组的开头中, 并返回该数组的长度
		- reverse
			- 将数组反转并返回这个新数组
		- splice(start, deleteCount [, ele1[, ele2 ...]])
			- 指定删除的位置和数量, 并在删除的位置添加新元素, 返回删除的元素
- 函数
	- 函数的声明
		- js中函数的声明不需要写返回值类型和参数类型
		- 第一种声明: `function 函数名(变量1, 变量2, ...){函数体}`
		- 第二种声明: `var 函数名 = new Function("变量1", "变量2", ..., "函数体")`
		- 第三种声明: `var 函数名 = function(变量1, 变量2, ...){函数体}`
	- 函数的调用
		- 函数在调用时, 可以不给形参赋值, 这时形参的值就是undefined
		- 函数在没有返回值时, 会返回undefined
	- 函数名也是变量(函数可以作为参数和返回值)
		- 案例: 匿名函数

				function func(fn) {
					alert("In func");
					fn();
				}
				
				func(function() {
					alert("In anonym");
				})
- 类
	- 类的声明
		- 案例

				function Person(name, age) {
					this.name = name;	//属性声明+初始化
					this.age = age;	//属性声明+初始化
					this.test = function(a) {	//方法声明
						alert(a);
					}
				}
		- js中, 类的声明和函数的声明使用相同的关键字, 类的"构造函数"与其属性合二为一
		- 类的声明中, 新变量直接赋值初始化, 不能用var关键字(函数声明也是)
		- 在调用对象时, 如果一个对象没有这个属性, 系统会自动为这个对象添加这个属性
			- 如在上面的Person类中没有addr属性, 但是可以直接`new Person().addr = "北京"`
	- 类的实例化
		- `var p1 = new Person("Bob", 18);`
	- prototype属性
		- 每个类都有一个prototype属性, 这个属性是每个对象公有的, 当调用一个对象的属性时, 系统会先在类中寻找, 找不到再去prototype中找(节省了内存)
		- 在prototype中添加属性(函数)的方法
			- 类.prototype.属性名
			- 注意对象不能直接调用prototype(调用后返回undefined)
		- 利用prototype变现实现继承

				Person.speak = function(words) {alert(words);};
				User(pwd) {
					this.pwd = pwd;
				}
				User.prototype.person = new Person();

				new User().person.speak("I'm Person's child class.");
- 自定义对象
	- 利用对象可以实时添加新属性的特征, 我们可以自定义对象
	- 通常这个自定义的对象来自Object类(可以认为这个类没有其他属性)
	- 自定义对象可以用来储存数据
	- 案例

			obj = new Object();	//或obj = {};
			obj.name = "name";
			obj.age = 8;
- js的常用方法和对象
	- String对象
	- Date对象
	- Math对象
	- Global对象
		- 固有对象, 不可实例化, 目的是把所有的全局方法集中在一个对象中, Global对象的方法可以直接调用
		- escape
		- eval
		- inFinite
		- isNaN: 判断一个变量是否是NaN
		- parseFloat
		- parseInt: 将一个字符串转为数字
			- 当一个字符串中有非数字字符和数字字符, 将最前面的数字字符转为数字
			- 当字符串前缀为0x时, 认为这个数组字符串为16进制
			- 当字符串前缀为0时, 认为这个数组字符串为8进制
		- unescape
- 事件机制
	- 单双点击事件
		- 单击事件: `<input type="button" value="测试单击事件" onclick="js代码(通常为函数调用)">`
		- 双击事件: `<input type="button" value="测试单击事件" ondblclick="js代码(通常为函数调用)">`
	- 鼠标事件
		- 鼠标悬停事件: `<div onmouseover="js代码"></div>`
		- 鼠标移动事件: `<div onmousemove="js代码"></div>`
		- 鼠标移出事件: `<div onmouseout="js代码"></div>`
	- 键盘事件
		- 键盘弹起事件: `<input type="text" onkeyup="js代码"/>`
		- 键盘按下事件: `<input type="text" onkeydown="js代码"/>`
	- 焦点事件
		- 获取焦点事件: `<input type="text" onfocus="js代码"/>`
		- 获取焦点事件: `<input type="text" onblur="js代码"/>`
	- 页面加载事件
		- 如: `<body onload="js代码"></body>`
		- 当onload被放在属性上时(或放在html的最下面), onload会在页面加载完毕后触发, 当onload直接在js代码中进行调用时, onload会在页面加载前(显示网页内容前)调用
		- 还可以为window对象添加onload事件, 效果与给其他标签添加onload的效果一致
	- 值改变事件
		- 如: `<select onchange="js代码"></select>`
	- 一个标签可以添加多个事件, 并且这些事件适用于所有标签
	- 通常, onchange事件会加给select标签, onload会加给body标签
	- 注意当一个标签有多个事件时, 事件间可能会有冲突(当事件的触发条件有重合时)
		- 如: 单双击事件同时加在一个标签中
	- 事件的阻断
		- 一些标签本身就会带有一些功能, 如a标签再被点击后会执行跳转, form会提交信息
		- 但是事件与标签的触发条件重合时, 会先执行事件
		- 若这时事件被执行后带有false返回值, 则标签本身功能被阻断(如a标签不执行跳转, form不提交信息)
		- 如: `<input type="submit" onclick="return 验证信息();"/>`
	- 超链接调用js函数
		- `<a href="javascript:函数名()">调用js函数</a>`
	- html标签的this关键字
		- html标签在调用js函数时, 可以传一个this参数
		- this指向标签自身
	- js动态动态添加事件(以下的element为一个已经被获取的元素对象)
		- element.onclick="js代码"
- window对象
	- BOM(Browser Object Model, 浏览器对象模型)
		- BOM提供了独立于内容的、可以与浏览器窗口进行互动的对象结构, 规范了浏览器对js的支持
		- BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象
	- Windows对象不需要实例化, 使用类型Math类, 并且window关键字可以省略
	- 框体方法
		- 警告框: window.alert(信息)
			- 平常写的alert方法其实是window.alert
			- 没有返回值
		- 确认框: window.confirm(信息)
			- 返回值
				- 确定时为true
				- 取消时为false
		- 提示框: window.prompt(信息)
			- 返回值
				- 点击确定时返回String对象(没有输入信息时返回空字符串)
				- 点击取消时返回null(注意与空字符区分)
	- 定时和间隔执行方法
		- 定时执行: window.setTimeout(code 函数对象, number 毫秒数)
		- 间隔执行: window.setInterval(code 函数对象, number 毫秒数)
	- 子窗口方法
		- 打开子窗口: window.open(String 子窗口url,String 窗口名,String 窗口配置信息,boolean replace)
		- 关闭子窗口: window.close()
			- window.close由子页面调用以关闭自己, 且当该页面不是子页面时该方法无效
	- 子页面调用父页面的函数
		- window.opener属性: 返回父页面对象
	- 地址栏属性
		- window.location
			- window.location.href可以直接访问并修改当前页面的url, 实现类似超链接跳转的功能(也可以是相对路径)
				- 如: `window.location.href="http://www.baidu.com"	//让当前页面跳转到百度`
			- window.location.reload(): 让页面刷新
	- 历史记录属性
		- window.history
			- window.history.forward(): 跳转到前一页面(->)
			- window.history.back(): 回退到后一页面(<-)
			- window.history.go(number index): 跳转到指定历史页面
				- 当前页面index为0, go(0)相当于刷新
				- 向前跳转为正, 跳一个页面index+1
				- 向后跳转为负, 跳一个页面index-1
	- 屏幕属性
		- window.screen
			- window.screen.width: 屏幕宽
			- window.screen.height: 屏幕高
	- 浏览器配置属性
		- window.navigator
			- window.navigator.userAgent: 获取浏览器ua
	- 主题面板属性: document对象
- document对象
	- 概念
		- document对象是window对象的属性
		- 浏览器对外提供的html文档对象, 通过document对象可以实现对html的动态变换
		- 浏览器在获取html文档后, 会将其解析入内存(类似xml的DOM解析), document是浏览器将内存内容解析为js格式的对象, js在操作document后, 浏览器又会将document解析回去, 修改真正的内存
	- 获取html元素对象
		- 直接获取
			- 通过id获取
				- document.getElementById(String Id)
			- 通过name获取对象数组
				- document.getElementsByName(String name)
				- 此方法通常在获取多选/单选按钮时使用(一下就可以获得一个group的所有按钮)
			- 通过class获取
				- document.getElementByClassName(String className)
				- 注意className不加`.`
			- 当出现多个id或name或class相同的元素时, 会得到一个元素数组
		- 间接获取(以下的element为一个已经被获取的元素对象)
			- 父子关系
				- element.childNodes: 获取包括所有子节点的数组
					- 注意这里的子节点包括元素与元素间的空格/换行符/制表符(和xml类似)
			- 子父关系
				- element.parentNode: 获取父节点(一个元素只能有一个父节点)
			- 兄弟关系
				- element.previousSibling: 获取前一个兄弟节点
				- element.nextSibling: 获取下一个兄弟节点
	- 操作html元素对象的属性(以下的element为一个已经被获取的元素对象)
		- 查看
			- element.type/name/id/...: 获取元素的type/name/id/...属性
			- 获取元素的自定义属性
				- 元素自定义的属性不能直接由`.属性名`获取
				- 需要使用`element.getAttribute(String 属性名)`的方法获取(此方法也适用于一般属性)
			- 注意: getAttribute拿到的属性值只能是默认值, `.属性名`的方式可以拿到实时的属性值
		- 修改
			- element.type/name/id/... = 修改的值: 将属性修改为对应值
			- 修改元素自定义的属性
				- setAttribute(String 属性名, 值)
				- 此方法也适用于一般属性
			- 尽量不要修改元素的id和name
	- 操作html对象的内容和样式
		- 获取元素内容
			- element.innerHTML
				- 这个获取的内容是这个标签中的所有文本(里面若还有标签那就是那个标签的源码)
			- element.innerText
				- 这个内容会无视掉标签(直接提取标签中的innerText)和空格/回车/换行符
		- 修改元素内容
			- element.innerHTML="内容"
				- 若内容中有html标签, 则会解析这些标签
			- element.innerText="内容"
				- 这会将element里面的内容全部变成文本信息, 即使里面有标签也不会被解析
				- 此方法极少用, 一般用innerHTML
		- 操作样式
			- 添加样式
				- element.style.样式=值
			- 修改样式
				- 覆盖样式: element.style="覆盖的内容"
				- 单项修改: element.style.样式=值
			- 删除样式
				- element.style.样式=""	//空字符串
			- 操作样式的本质其实就是修改元素的style属性, 覆盖其实就是元素属性的style优先级高于style标签, 并非将style标签中的值修改了
			- 通过元素的class属性修改样式
				- 获得class: element.className
				- 修改class: element.className="另一个class"	//不要.
					- 当修改为空字符串时, 相当于删除class属性
	- 操作html的文档结构
		- 增加节点
			- 利用元素的innerHTML属性可以增加子节点
				- 直接修改innerHTML属性会失去用户操作的信息(如input-file标签的文件选择信息)
			- 利用创建元素的方法
				- createElement("标签类型")	//如var inp = document.createElement("input")
				- 在创建标签后需要给标签添加属性和样式, 其操作与上面所述一致
				- 属性设置完毕后用父节点的appendChild(元素对象)的方法添加到document中
				- 这样的创建方式可以避免父节点对其他子节点产生影响
		- 删除节点
			- 利用元素的innerHTML属性可以删除子节点
			- 利用元素的removeChild(子节点对象)的方法
				- 此方法使用较多
				- 有时一个删除按钮需要删除包括自身的多个元素, 在写源码时可以将这几个元素打包在一个父节点内, 删除时就可利用按钮的父父节点的removeChild来删除父节点
			- 动态创建时的删除
				- 若需要删除的节点是被js动态创建的, 则可在动态创建时就添加一个input-button, 这时就只需要给button添加一个onclick属性, 在属性中直接创建一个function方法(这时需要删除的元素地址已知, 就不需要间接通过父父节点删除的方式了)
	- document操作form元素
		- 获取form表单
			- 使用document.getElementById/Name()
			- 直接属于document的属性值进行获取
		- 获取form的表单对象(input-text/input-password/...)
			- form对象.elements
		- 提交表单: form对象.submit()
		- 清空表单: form对象.reset()
	- document操作表格(一下table为已获取表格对象, tr为已获取行对象)
		- 在表格中不能通过removeChild方法对表格进行删除
		- 行操作
			- 删除行: table.deleteRow(行号)
				- 行号从上到下, 由0开始, 可由tr的rowIndex属性获取
			- 添加行: table.insertRow(行号)
				- 在指定行号前插入一行
		- 列操作
			- 获取列: 
				- tr.cells: 获取所有本行的列
			- 删除列: tr.deleteRow(列号)
				- 列号从左到右, 由0开始, 可由dr的colIndex属性获取
			- 添加列: tr.insertRow(列号)
				- 在指定列号前插入一行