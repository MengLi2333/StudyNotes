# 20. 数据库-Oracle、SQL语句
- 数据库(Oracle)
	- 数据库的意义: 帮助管理硬盘数据
	- SQL语言的分类
		- DQL(数据查询语言)
			- select
		- DML(数据操作语言)
			- insert/update/delete
		- DDL(数据定义语言)
			- create/alter/drop
		- DCL(数据控制语言)
			- grant/revoke
		- TCL(事务控制语言)
			- SAVEPOINT/ROLLBACK/SETTRANSACTION/COMMIT
	- SQL知识点汇总
		- 数据的读取
			- 单表查询
			- 多表查询
			- 子查询
		- 数据的存储
			- 增加
				- 增加一条数据
				- 增加一张表
			- 删除
				- 删除数据
				- 删除表
			- 修改
				- 修改数据
				- 修改表信息
		- 通过SQL语句管理用户
			- 创建用户
			- 修改用户
			- 删除用户
		- 通过SQL语句进行事务管理
	- 关系数据库基本概念
		- 关系: 整个二维表
		- 关系名: 表格名称
		- 元组: 行数据(记录)
		- 属性: 列数据(字段)
		- 属性名: 列名称(字段名)
		- 主键: 唯一确定元组的属性名(关键字)
		- 域: 属性的取值范围
		- SQL语句大小写不敏感
	- SQL查询语句执行顺序: `from -> where -> group/order -> select`
- 单表查询
	- 查询表的所有数据: `select * from 表名;`
	- 查询表中指定字段(字段, 即描述数据的值)的值: `select 字段名1, 字段名2, ... from 表名;`
	- 给查询结构中的字段使用别名: `select 字段名1 as "字段别名", 字段名1 as "字段别名", ... from 表名;`
		- 其中as 和 双引号都可以省略
	- 字符串拼接
		- MySQL: concat函数, +
		- Oracle: concat函数, ||
	- 去重: `select distinct 字段名1, 字段名2, ... from 表名`
		- 只会列出所展示的字段名不同的记录
	- 查询结果排序
		- 单字段: `select 字段名1, 字段名2, ... from 表名 order by 字段名 [asc/desc]`
		- 多字段: `select 字段名1, 字段名2, ... from 表名 order by 字段名1, 字段名2, ... [asc/desc]`
	- 对于是数值的字段, 还可以对字段进行四则运算, 如: `select id*2+100 from t_user`
	- where子句查询
		- 条件筛选: `select 字段名1, 字段名2, ... from 表名 where 筛选条件`
		- 筛选条件
			- 字段名 is [not] null: 字段名是否为空
			- not关键字: 逻辑运算中的非
			- and/or: 两个条件做且/与运算
				- 与许多语言相同, and的运算优先级大于or
			- >, >=, <, <=, =, !=, <>
			- like关键字, 如挑选name字段中包含m字母的: `select name from 表名 where name like "%m%"`
				- 其中%表示可以有任意个字符, 或者没有字符
				- _表示任意的一个字符
				- \是转义字符
				- escape 可以将一个字符变为转义字符
			- in关键字, 类似于python的in关键字, 如: `select name, id from t_user where id in (1, 2)`为挑选id为1或者2的记录
			- between-and关键字, 如: `select name, id from t_user where id between 10 and 20`为挑选id在10和20之间的记录(包括10和20)
- SQL函数
	- 函数分为单行函数, 多行函数, 转换函数, 其他函数
	- 单行函数
		- 字符函数
			- initcap(char)	--	首字母大写
			- lower(char)	--	全小写
			- upper(char)	--	全大写
			- ltrim(char, set)	--	左剪裁, 如: `ltrim("aaabc", "aa")`得到abc
			- rtrim(char, set)	--	右剪裁
			- translate(char, from, to)	--	按字符翻译, 如: `translate("jack", "abcd", "1234")`得到j13k
			- replace(char, search_str, replace_str)	--	字符串替换
			- instr(char, substr[, pos])	--	查找子字符串位置
			- substr(char, pos, len)	--	取子字符串
			- concat(char1, char2)	--	拼接字符串
		- 数组函数
			- abs(n)
			- ceil(n)
			- sin(n)
			- cos(n)
			- sign(n)	--	与数学中的sign函数相同, 整数为1, 负数为-1
			- floor(n)
			- power(m, n)
			- mod(m, n)
			- round(m, n)	--	四舍五入到小数点后n位
			- trunc(m, n)		--	截断到小数点后n位
			- sqrt(n)
		- 伪表dual: 为了某些验证计算而建立的表, 如`select ceil(1.2) from dual`用于验证ceil(1.2)的值是多少
		- 日期函数: 
			- month_between(str_date1, str_date2)	--	返回两个日期间的月份
			- add_month(str_date, n)	--	把月份数n加到日期上, n为负数时减少月份
			- next_day(str_date, str_weekday)	--	这个日期的下一个星期几是多少号
			- last_day(str_date)	--	这个日期的该月的最后一天
			- round(to_date(str_date), str)	--	str为DAY/MONTH/YEAR, 分别为按周/月/年四舍五入
	- 多行函数
		- 注意多行函数不能和字段/单行函数直接混用, 除非分组
		- max
		- min
		- avg
		- sum
		- count, 如: `select count(distinct name) from t_user`
			- count会把null自动过滤
		- where子句中不能出现多行函数, 因为select的执行顺序是先from 表名, 再where查询, 再分组, 再用多行函数进行统计
	- 转换函数
		- to_number(数值类型的字符)
		- to_char(数值或者日期)
			- 数值转字符串时可以指定显示格式
				- 如: `select to_char(123456789, "L999,999,999") from dual`得到￥123,456,789
				- 9表示占位
				- 0也表示占位, 并且当转换数字位数不足时, 用0给转换数字补位
				- L表示人民币
				- $表示美元
			- 日期转字符串时也可以指定格式, 如: to_char(date, "yyyy-mm-dd")
		- to_date(日期格式的字符)
			- 日期转换时可以指定日期的格式, 如: to_date("1973-01-01", "yyyy-mm-dd")
			- 不指定格式则使用默认的日期格式
			- mysql中为str_to_date()
		- SQL语句也会有隐式的类型转换
	- 其他函数
		- nvl(字段, 默认值)
			- 当字段为null时, 给一个默认值, 不是null则是自身
			- MySQL中为ifnull(字段, 默认值)
		- nvl2(字段, 表达式1, 表达式2)
			- 当字段不为null时, 执行表达式1, 是null执行表达式2
		- decode(字段, 情况1, 表达式1, 情况2, 表达式2)
			- 当字段与情况1相等时, 执行表达式1, 当字段与情况2相等时, 执行表达式2
			- 在mysql中是由case..when ..then..when..then..else..end实现
- 分组
	- group by关键字
	- 分组后, 只能显示分组的字段和多行函数
	- 如: `select gender, avg(height) from t_people group by gender`是显示每个性别对应的平均身高
	- 多次分组, group by 字段名1, 字段名2, ... 
	- 分组查询的筛选: having关键字
		- 区别于where, where是在分组或多行函数执行前进行的, 而having是在分组或多行函数执行后进行的
		- having子句可以使用多行函数
		- having必须在有分组时才可以使用
- 增删改
	- 主键: 唯一标识一条数据
		- 主键必须非空
	- 增加信息: insert
		- 如: `insert into t_user (id, name) values (1, "lalala")`
		- values的个数要与字段个数一一对应
		- 如果是全字段插入, 则可以不写字段名
		- insert into 还可以插入一个查询的结果集, 但前提是这个结果集的字段数量必须要和表的字段数量和类型一致
	- 删除数据: delete
		- 如: `delete from t_user where id = 1`
		- 若不加条件则会删除表中的所有信息
		- truncate table 表名: 删除表中的所有信息(效率高于delete)
	- 更新数据: update
		- 如: `update 表名 set 字段名1=新的值, 字段名2=新的值, ... where 条件`
	- 数据的备份
		- 表级别的备份
			- 全部备份
				- 如: `create table t_userBak as select * from t_user`
			- 部分备份
				- 如: `create table t_userBak as select id, name from t_user`这样只备份了id和name字段
			- 注意只会备份表的结构和数据, 不会备份约束(主键)
			- 语法分析: create table 新的表名 as select..., 这个新建的表其实是按照select语句执行后得到的结果集来进行备份的, 所以select语句得到什么结果, 新表就是什么样子
- 多表联合查询
	- SQL92方法
		- 笛卡尔积
			- 如: `select * from 表1, 表2`得到的结果是一张表, 共有: (表1的条数) * (表2的条数) 条数据
			- 若表1与表2的字段有重名, 则用`表名.字段名`的方式加以区分
		- 等值连接
			- 先做表的笛卡尔积, 在进行等值筛选
			- 如: `select * from 表1, 表2 where 表1.字段 = 表2.字段`
		- 不等值连接
			- 与等值连接类似, 先做表的笛卡尔积, 在进行不等值筛选
			- 如: `select * from 表1, 表2 where 表1.字段1 < 表2.字段2`
		- 自连接
			- 自连接即一张表与自己做笛卡尔积
			- 在自连接中必须为表起别名, 以便区分
			- 如: `select t1.*, t2.* from t_user t1, t_user t2`
		- 外连接
			- 左外连接
				- 当做等值连接时, 只要判断条件的一边为null则整条信息不被显示
				- 这时在等号右边加上(+)可让左边的信息完全显示出来
			- 右外连接
				- 在等号左边加上(+)可让左边的信息完全显示出来
	- SQL99方法
		- 交叉连接
			- 交叉连接就是SQL92的笛卡尔积
			- 使用cross join关键字
			- 如: `select * from t_user cross join t_user2`
		- 自然连接
			- 使用natural join关键字
			- 如: `select * from t_user natural join t_user2`
			- 结果与SQL92中的等值连接一样, 只是系统自动筛选(筛选两个表中所有同名的字段), 不用自己写where条件了
		- 内连接
			- 使用inner join和using/on关键字
			- 案例1: `select * from t_user inner join t_user2 using(id, name)`
				- 制定系统需要进行筛选的字段(可以是多个), 这里的字段必须是两张表都需要有的
			- 案例2: `select * from t_user inner join t_user2 on t_user.name=t_user2.ename`
				- 使用on关键字可以让系统筛选两张表不同名的的字段
				- 普通筛选条件可以写在on里面, 但是不建议这样写, 因为这样影响可阅读性
			- 内连接上的inner关键字可以省略
		- 外连接
			- 左外连接
				- 使用left outer join和using/on关键字
				- 如: `select * from t_user left outer join t_user2 using(id)`
				- 与SQL92的左外连接结果一致
			- 右外连接
				- 使用right outer join和using/on关键字
				- 如: `select * from t_user right outer join t_user2 using(id)`
				- 与SQL92的右外连接结果一致
			- 全外连接
				- 使用full outer join和using/on关键字
				- 如: `select * from t_user full outer join t_user2 using(id)`
				- 在这里t_user和t_user2的没有连接上的信息都会被显示
			- 外连接上的outer关键字可以省略
		- 自连接
- 子查询
	- 子查询就是select语句的嵌套
	- 当查询的筛选条件不明确的时候, 考虑使用子查询
	- 单行子查询
		- 如: `select * from people where height > (select avg(height) from people)`
		- 单行子查询就是要求子查询的结果只能有一个
	- 多行子查询
		- 使用any/all/in关键字
		- 如: `select * from people where height > any (select height from people)`
		- 多行子查询就是子查询的结果可能有多个
- 账户管理
- 二维表管理
	- 二维表的创建
		- `create table 表名[as select...]`
			- 后面的as子句: 可以利用select语句的查询结果来作为新表的数据
	- 二维表的约束
		- 主键约束(非空/唯一)
		- 非空约束
		- 检查约束
		- 唯一约束
		- 外键约束
			- 级联删除
	- 二维表的维护
		- 添加新的字段
		- 修改原有字段	
			- 修改字段名
			- 修改字段类型
			- 删除字段
		- 修改表名
		- 删除表
- sequence序列
	- 作用: 作为主键的值, 避免主键冲突

		create sequence cc
			start with 10
			increment by 2
			max 10000000
			cache 10;
		select cc.nextval from dual;
		select cc.currval from dual;
- index索引
	- 意义: 增加搜索效率
	- 系统会自动为主键添加索引
- view视图
	- 意义: 将一张表进行"权限"分配, 保护核心数据
	- 用一张表的部分字段创建若干视图, 得到视图的普通用户只能操作原表的指定字段
	- 视图还可以设置是否只读
- 分页查询
	- 意义
		- 当一个表中的数据量特别大时, 一次性查找完会消耗很多资源, 并且有些时候并不是需要查找完所有数据, 于是就有了分页查询
		- 分页查询指一次性查出指定个数的数据, 下次查询再继续查询
	- rownum关键字: 为每行的查询结果自动编号
		- 利用rownum关键字可以为查询结果进行分页
		- 案例: 显示查询结果的第n条到第m条

			select *
			from (
				select rownum as row, e.*
				from emp
				where rownum <= m
			)
			where row >= n;
		- rownum只能做<, <=的判断