# 第1章 上升到面向对象

- 什么是面向对象
  - 在本人看来, 面向对象是一种解决问题的思考方式, 即以对象为中心来思考问题的解决方法
  - 具体来说, 就是将一个问题拆分成若干部分, 由各个对象完成其中特定的部分

- 面向对象解决的是什么问题
  - 面向对象更加关注程序的高层结构, 利用分治的思想来实现一个规模较大的系统
    - 如同一个公司需要分出不同的部门, 每个部门都关注一个特定方面的问题
  - 即面向对象解决的是规模较大的系统的实现的问题
  - 其优点是使用面向对象设计出来的系统易于扩展和维护, 且更加易于融入工程学的思想
- 为什么算法通常不使用面向对象设计
  - 算法更多解决的是小规模(或局部)的问题, 这类问题通常不需要关注什么高层结构, 而更加关注底层的数据结构
- 什么是面向对象技术
  - 面向对象技术是一系列指导软件构造的原则(如抽象、封装、多态等), 并通过语音、数据库和其他工具支持这些原则
- 面向对象技术的优势
  - 沟通(开发人员和普通用户间的沟通)
    - 面向对象技术更顺应人类的思维习惯, 即使没有程序开发基础的人也能很好理解
  - 稳定
    - 功能的变更不会造成对象的较大改变
  - 复用
    - 同样的对象可以在不同的系统中使用
- 对象的定义
  - 对象(Object) = 边界(Boundary) + 标识(Identity) + 状态(State) + 行为(Behavior)
  - 状态(State) = 属性(Attribute) + 关系(Relationship)
  - 行为(Behavior) = 操作(Operation) + 方法(Method) + 状态机(State Machine)
- 面向对象技术的相关原则
  - 封装(Encapsulation)
  - 复用(Reuse)
  - **抽象(Abstraction)**
  - 分解(Decomposition)
  - 泛化(Generalization)
  - **多态(Polymorphism)**
  - 分层(Hierarchy)

# 第2章 可视化建模技术

- 什么是模型
  - 广泛地讲, 模型是对现实世界的简化
  - 对于软件领域, 模型是对目标系统的简化, 是系统的蓝图
- **建模的目的**
  - 根本目的: 帮助开发人员更好地理解待开发的系统
  - 具体的目的:
  - 将待开发系统进行**可视化**表示
  - 可以精确地**描述**系统的结构和行为
  - 提供构造系统的**模板**
  - **文档化**设计决策, 便于存储和以后参考和使用
- 建模的基本原则
  - 选择合适的模型
  - 模型具有不同的精确程度
  - 好的模型是与现实相联系的
  - 单一的模型是不够的
- UML统一了什么
  - 开发生命周期
  - 应用领域
  - 实现语言和平台
  - 开发过程
  - 自身的内部概念
- 适合使用UML的情况
  - 项目采用的OO方法论
  - 希望提高交流效率
  - 系统的规模和设计都比较复杂
  - 希望记录已成功项目的设计方案
  - 采用一套通用的图形语言
- UML语义结构
  - Supplemental Modeling
    - 用例Use Cases, 部署Deployments, 信息流Information Flows
  - 行为语义Behavioral Modeling
    - 状态机State Machines, 活动Activities, 交互Interactions, 动作Actions, Common Behavior
  - 结构语义Structural Modeling
    - 值类型Values, 分类器Classifiers, 包Packages, Common Structure
- UML的语法结构的定义
  - 采用UML元模型来定义
  - 通过UML类图描述各元素的语法
- **UML 2概念模型**
  - 详见书p29
- **UML "4+1"视图**
  - 视图由不同的 UML 图组成
  - Use Case View
    - Business Use Case Model
      - State/Activity Model
  - Logical View
    - Business Object Model
  - Implementation View
  - Process View
    - 用于描述系统的运行时架构
  - Deployment View
    - 用于描述系统的部署
- UML分析设计过程
  - 业务建模 -> (系统)用例建模 -> (系统)用例分析 -> 架构设计 -> 构件设计 -> 代码实现

# 第3章 业务建模

- 业务
  - 业务是指某个组织或者组织单元，可看作 一种包含了人、机器、资源的"系统"
- 业务建模
  - 采用软件建模方法分析和理解待开发业务, 描述业务流程的过程

- 业务建模的意义
  - 通过业务建模认识业务本质
  - 该业务本质是后续(系统)用例建模的基础
- 业务建模的目标
  - 理解将要实施系统的**目标组织结构**和**动态特性**
  - 理解当前目标组织结构中的问题, 并明确**改进的潜力**(TQCSEK)
  - 确保客户、最终用户和开发人员就目标组织有**统一的理解**
  - 获取用于支持目标组织的**系统需求**

## 业务用例建模

- 业务用例模型(Business Use-Case Model)的作用
  - 用于说明业务预期功能, 以及确定组织的各个角色和可交付工件
- 业务用例建模需要从以下3个方面来实施
  - 识别业务参与者
  - 识别业务用例
  - 描述业务用例(流程)
    - 活动图和顺序图可用于描述业务流程
- 识别业务参与者
  - 确定: 在业务之外, 与业务进行交互的人或组织
- 识别业务用例
  - 确定
    - 为业务参与者提供的价值
    - 体现企业业务本质, 是有意义的目标
  - 识别套路
    - 从业务参与者的角度, 分析业务给参与者提供的价值
    - 从业务内部的角度, 分析活动的目标
- 利用活动图描述业务用例
  - 详见书p60

## 业务对象模型

- 业务对象模型(Business Object Model)
  - 勾勒出实现业务关系中的人、事物、设备、资源以及它们之间的关系

- 业务对象模型元素
  - 业务工人Business Worker
    - 表示在业务内部承担一系列职责的人
  - 业务参与者
    - 在业务之外, 与业务有关的人或物
  - 业务实体Business Entity
    - 表示业务内部使用或产生的可交付工件、资源和事件
  - 业务用例实现Business Use Case Realization
    - 显示了协作的业务工人和业务实体如何执行某个工作流程
- 业务对象模型分为两个部分
  - 静态模型
    - 类图(详见书p67)
  - 动态模型
    - 活动图、顺序图

# 第4章 用例建模

- 用例建模是一种有效的需求定义手段
- 什么是需求
  - 需求是客户可接受的、系统必须满足的条件或具备的能力
  - RUP的FURPS+需求模型将需求分为以下几种类型: 
  - 功能性(Functionality)
  - 可用性(Usability)
  - 可靠性(Reliability)
  - 性能(Performance)
  - 可支持性(Supportability)
  - +(其他类型的需求, 如设计约束、实施需求、接口需求、物理需求等)
- 需求的特点
  - 难捕获
  - 易变
- **用例建模的适用场合**
  - 系统由功能需求所主导
  - 系统具有很多类型的用户, 系统对他们提供不同的功能
  - 系统具有很多接口
- **用例建模的不适用场合**
  - 系统由非功能需求所主导
  - 系统具有很少的用户
  - 系统具有很少的接口

## 从业务模型获取需求

- 寻找业务改进点
  - 流程控制
    - 手工的信息流转方式难以满足业务需求, 且容易出错
  - 复杂业务逻辑
    - 手工完成有很大难度或工作量过大
  - 使用业务对象
    - 某些活动主要是对业务对象的操作, 手工方式难以保证操作方式的合法性, 且难以记录操作的历史等信息
  - 自动化业务
    - 某些业务需要定期、定时进行处理, 其操作过程也不涉及复杂交互
- 定义项目远景
  - 好的远景应该具有的特点(SMART): 
  - 具体的(Specific)
  - 可测量的(Measurable)
  - 可实现的(Achievable)
  - 相关的(Relevant)
  - 基于时间的(Time-based)
- 导出系统需求
  - 对于每个业务改进点, 明确是否是为了达到远景目标的需要, 
  - 如果是, 则作为软件需求而存在, 并把相应的模型转化为系统模型; 
  - 如果不是, 则不作为需求而存在, 或作为潜在需求考虑, 或直接抛弃

## 启发式获取需求

### 识别参与者

- 识别参与者的要点
  - 系统外: 在系统之外
  - 系统边界: 通过系统边界直接与系统交互
  - 系统角色: 是一个角色, 而非具体的人或物
  - 与系统交互: 参与者与系统交互的过程是系统所需要处理的, 即系统职责
  - 任何事物: 可以是人、外部系统、外部因素、时间等外部事物
- 判断技巧
  - 参与者是信息的起点或终点
- **确定参与者的思路**
  - 系统在哪些部门使用
  - 谁向系统提供信息、使用和删除信息
  - 谁与系统的需求有关联
  - 谁对系统进行维护
  - 与外部系统是否有关联
  - 时间参与者(用于激活那些系统定期的、自动执行的用例)
- 参与者之间可以存在泛化关系
- 文档化参与者
  - 描述
  - 基本特征
  - 相关的涉众和典型用户

### 识别用例

- 识别用例的要点
  - 可观测: 用例的定义只关注系统对外体现的行为(用例动作的主语是系统)
  - 结果值: 每个用例都会对外界参与者产生一个有价值的结果
  - 系统执行: 用例产生的结果是由系统所产生的
  - 由参与者执行: 用例的识别和定义都是从观测者角度出发的, 以参与者的视角获取和命名用例
- **确定用例的思路**
  - 参与者的日常工作是什么
  - 参与者在业务中承担什么样的作用
  - 参与者是否会生成、使用或删除与系统相关的信息
  - 参与者是否需要把外部变更通知给系统
  - 系统是否需要把内部事情通知给参与者
  - 是否存在进行系统维护的用例
- 用例粒度
  - 用例粒度不能过小
  - 如用例为"增删改查"

## 用例的描述

- 用例文档的组成
  - 用例名、简要描述
  - 参与者与涉众
  - 相关用例
  - 前置条件、后置条件
  - 事件流
    - 基本路径
    - 备选路径
  - 补充约束
    - 字段列表、业务规则
    - 非功能需求、设计约束
  - 待解决问题
  - 相关图 (用例图、活动图、类图)
- **参与者与涉众的区别和关系**
  - 用例的涉众是指受用例所代表的业务影响(或者说与当前用例有利益关系)的系统内外部人员或组织
  - 把用例比作一台戏, 参与者和系统就是这台戏的演员, 而涉众则是观众, 戏的好坏由观众来评价

## 重构用例模型

- 重构的角度有
  - 用例关系
  - 用例分级
  - 用例分包

### 用例关系

- 用例关系
  - include
    - 包含指向被包含
  - extend
    - 扩展指向被扩展
  - generalization
    - 泛化指向被泛化

- **扩展关系 vs 包含关系**
  - 共同点
    - 都与基用例相联
    - 当子用例流执行完毕, 控制将返回到基本事件流中原来被中断的那个位置恢复执行
  - 不同点
    - 出发点不同
      - 包含关系: 便于子用例的复用
      - 扩展关系: 通过扩展点在不影响基用例的情况下附加行为
    - 达到的效果不同
      - 包含关系: 基用例中的一部分业务放在子用例中
      - 扩展关系: 基用例处理一般情况, 一些特殊业务放在子用例中
    - 执行子用例方式不同
      - 包含关系: 基用例中直接引用子用例
      - 扩展关系: 主用例达到一定条件触发扩展点, 子用例通过扩展点触发
    - 使用方式不同
      - 包含关系: 基用例不够完整, 一般要联合子用例为参与者提供价值
      - 扩展关系: 基用例相对完整, 可以单独为参与者提供价值
    - 依赖方向不同
      - 包含关系: 主用例依赖子用例, 子用例相对独立
      - 扩展关系: 子用例依赖主用例, 主用例相对独立

### 用例分包

- 对于大规模系统, 当用例数量很多时, 难以在一个层次上一次性描述所有用例
- 常见的分包方式
  - 基于业务主题的分包
  - 按照参与者分包
  - 基于开发团队的分包
  - 基于发布情况的分包

### 用例分级

- 拥有较高级别的用例
  - 对架构设计有重要影响的用例
  -  体现系统核心业务流程的用例
  - 存在开发风险的用例
  - 涉及新技术或需要创新的用例
  - 能够尽快投入使用并带来直接经济效益的用例

# 第5章 用例分析

- 分析与需求的关系
  - 分析模型建立在用例模型的基础上
  - 用例模型确定了分析模型的结构
  - 用户视角理解用户问题过渡到开发团队视角分析用户问题
- 分析模型可以保持从需求、分析到设计的可跟踪性
- 分析模型包括两个层次
  - 架构分析、用例分析

- 构造用例实现后需要完成的事情
  - 完善用例文档
  - 识别分析类
  - 分析交互
  - 完成参与类类图
  - 处理用例关系

## 架构分析

- 架构分析
  - 架构分析的过程就是定义系统高层组织结构和核心架构机制的过程

- B-C-E三层架构
  - 以构造型`<<layer>>`表示系统不同层次
  - 边界层(Boundary)负责系统与参与者之间的交互
  - 控制层(Control)处理系统的控制逻辑
  - 实体层(Entity)管理系统使用的信息
- 分析机制
  - 分析机制是架构机制的一种
  - 分析机制用于非功能需求的建模

## 从用例行为中识别分析类

- 分析类
  - 分析类代表了"系统中必须具备职责和行为的事物"的早期概念模型
- 三类分析类
  - 边界类: 系统及其参与者的边界
    - `<<boundary>>`
  - 控制类: 系统的控制逻辑
    - `<<control>>`
  - 实体类: 系统使用的信息
    - `<<entity>>`

## 分析交互

- 利用交互图将用例行为分配给类

- 职责分配的方法
  - 以分析类的构造型作为分配标准
    - 边界类: 承担与参与者进行通信的职责
    - 控制类: 承担协调用例参与者与数据操作之间交互的职责
    - 实体类: 承担对被封装的内部数据进行操作的职责
  - 专家模式: 将职责分配给具有当前职责所需要的数据的类
    - 如果一个类有这个数据, 就将职责分配给这个类
    - 如果多个类有这个数据
      - 将职责分配给其中的一个类, 并对其它类增加一个关系
      - 将职责放在控制类中, 并对需要该职责的类增加关系
      - 创建一个新类, 将职责分配给该类, 并对需要该职责的类增加关系

### 顺序图(Sequence Diagram)

- 对象(Object)
  - 对象、对象的生命线、对象的执行发生和对象的删除
- 消息(Message)
  - 简单消息、同步消 息、异步消息、返回消息
- 顺序图中的交互片段
  - 可选(opt)
    - 该片段只有在守卫条件成立时才执行
  - 选择(alt)
    - 用水平虚线分割成几个分区
    - 每个分区都有守卫条件, 当守卫条件为真时执行
  - 循环(loop)
    - 在守卫条件为真的情况下循环执行
  - 并行(par)
    - 几个分区并行/并发执行
- 符号
  - `[]`
    - 执行的条件用`[]`括起来描述
  - `*`
    - 循环条件要在条件前加上`*`来描述
  - `{}`
    - 其他约束用`{}`括起来
- ref引用

### VOPC图

pass

## 定义分析类

- 定义职责
  - 职责的分类
    - 做(Do)型职责
    - 知道(Know)型职责
  - 获取职责
    - 从交互图中获取
    - 从非功能需求中获取
- 职责的描述
  - 通过类图描述
  - 通过文本描述(CRC卡)
- 定义属性

### 定义分析类的关系

- 关联关系
  - A uses B
  - A is ... of B
- 细化关联关系
  - 名称: 动词短语
  - 端点和端点名
  - 多重性表达式
    - `*`, `1..*`, `1-40`, `5`, `3,5,8`, ...
  - 定义关联类
- 聚合关系
- 泛化关系

# 第8章 架构设计

- 软件设计至少包括
  - 描述系统的架构
    - 系统如何分解和组织构件
  - 描述构件间的接口
  - 描述构件
    - 各个构件的实现细节
- 3种设计策略
  - D-设计(Decomposition design)
    - 将系统映射为构件片(component pieces)
  - FP-设计(Family Pattern design)
    - 目标是探求一定范围的通用性
  - I-设计(Invention design)
    - 基于概念化原型作系统分析, 定义系统以满足所发现的需要和需求

- 架构的具体工作
  - 确定核心元素
    - 在架构的中高层, 以"分析类"为出发点, 确定相应的"核心设计元素"
  - 引入外围元素
    - 在架构的中低层, 以"分析机制"为出发点, 确定满足分析类要求的"设计机制"
  - 优化组织结构
    - 按照高内聚、低耦合的基本原则, 整理并逐渐充实架构的层次和内容
  - 定义设计后的组织结构
    - 考虑设计完成后系统实现、运行以及部署等阶段的组织结构

## 包图

- 包
  - 包是一种将模型元素分组的机制
  - 是一个容器, 用来包含其他UML元素
- 包间的依赖关系
  - 普通依赖关系
  - 合并关系(merge)
    - 若合并和被合并的包中有相同名字的类, 则该类(在合并包中的)会被合并
  - 公有导入/导入关系(import)
    - 导入后的元素在当前包内的可见性不变
    - 若导入和被导入的包中有相同名字的类, 则该类(在导入包中的)会被合并
  - 私有导入/访问关系(access)
  - 导入后的元素是私有的, 对外不可见
- 分包的原则
  - 职责相似
  - 协作关系

## 确定设计元素

- 设计元素(Design Elements)
  - 指能够直接用于实现(编码)的模型要素
  - 通过确定设计元素来改进分析类, 使之成为适当的设计模型元素, 从而指导后续的实现
- 主要的设计元素
  - 包(Package)
  - 设计类(Design Classes)
  - 子系统(Subsystem)
  - 接口(Interface)
  - 主动类(Active Class)
    - 代表系统内的控制线程

## 引入设计机制

- 三类架构机制
  - 分析机制、设计机制、实现机制

## 确定运行时架构

- 主要内容
  - 确定独立的控制线程(或进程), 并且将设计元素映射到控制线程
- 通过构造型描述进程和线程
  - `<<process>>`
  - `<<thread>>`
- 设计元素分配到进程的策略
  - 从内到外
    - 将彼此密切协作, 并且必须在同一控制线程中执行的元素组合起来
  - 从外到内
    - 为每个外部激励确定一个独立控制线程
- 进程关系
  - 进程之间的关系必须支持设计元素之间的关系

## 描述系统部署

- 部署图建模元素
  - 节点(Node)
    - 物理的运行时计算资源
  - 连接(Connection)
    - 物理媒介

- 在节点间分配进程

# 第9章 构件设计

## 用例设计

- 用例设计的主要活动
  - 利用交互图改进用例实现
  - 改进对设计类的操作需求
  - 改进对子系统和它们的接口的操作需求
- 设计重点
  - 控制类职责的实现
- 在交互图中表示子系统
  - 为每个子系统定义一个代理类, 代表特定的子系统
  - 或引入子系统接口

## 子系统设计

- 子系统设计步骤
  - 将子系统行为分配给子系统元素
  - 描述子系统内部元素
  - 定义子系统间的依赖关系

## 类设计

- 类设计目标
  - 确保类可为用例实现提供必需的操作
  - 确保提供足够的信息可明确无误地实现
  - 处理和类相关的非功能需求

- 类设计的主要内容
  - 创建初始设计类
  - 定义操作
  - 定义方法和状态
  - 定义属性
  - 定义关系
  - 处理其它问题

### 状态机图

- 方法的实现往往受对象的状态影响, 采用状态机图建模
- 状态(state)的内部结构
  - 入口动作、出口动作
  - 状态活动、内部转移
  - 延迟事件
  - 子状态机
- 转移(transition)的三个要素
  - 事件(event)
    - 事件发生时转移才有可能发生
  - 守卫条件(guard condition)
    - 当事件发生时, 只有守卫条件为真才发生转移
  - 动作(action)
    - 当转移发生时所执行的动作
    - 该动作应当是原子操作

- 复合状态
  - 复合状态是含有一组子状态的状态

# 图

## 业务建模

- 业务用例图
  - 元素
    - 业务用例
    - 业务参与者
    - 关联关系
- 活动图
  - 描述业务/系统用例
  - 元素
    - 起点
    - 终点
    - 流结束
    - 控制流
    - 活动节点
    - 发送事件
    - 接收事件
    - 决策点
      - [条件]
    - 分流/合流
    - 分区
- 业务对象模型
  - 元素
    - 业务工人
    - 业务实体
    - 泛化关系
    - 关联关系
      - 关联关系名(动词)

## 系统建模

- 用例图
  - 系统边界
  - 系统用例
  - 系统参与者
  - 关联关系
  - 包含/扩展/泛化

## 用例分析

- 用例实现
  - 用例实现
  - 用例
  - 实现关系
- 顺序图
  - 边界类
  - 控制类
  - 实体类
  - 生命线
  - 控制流
    - 编号 + 描述
  - 框
- 通信图
  - 边界类
  - 控制类
  - 实体类
  - 控制流
    - 编号 + 描述
- VOPC
  - 边界类
  - 控制类
  - 实体类
  - 关联关系
- 类图
  - 类
  - `<<interface>>`
  - 关联关系
    - 角色 + 多重性 + 关系名
  - 泛化/组合/聚合

## 架构设计

- 包图
  - 包
  - 依赖关系
  - 包含/访问/合并
- 进程视图
  - `<<process>>`
  - `<<thread>>`
  - 依赖关系
  - 组合关系
- 部署图
  - 节点
  - 关联关系

## 构建设计

- 活动图
- 类图
- 状态机图
  - 初态
  - 终态
  - 状态
  - 转移
    - 事件[守卫条件]/动作