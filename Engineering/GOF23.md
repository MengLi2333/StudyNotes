# Preface
- 设计模式是从建筑学的工程问题中引用过来的
- 设计模式的重要性
	- 为以后(的代码)考虑
	- 案例
		- 建大厦 vs 建小木屋
## 按表现分类

- 创建型
	1. Factory Method（工厂方法）
	2. Abstract Factory（抽象工厂）
	3. Builder（建造者）
	4. Prototype（原型）
	5. Singleton（单例）
- 结构型
	6. Adapter Class/Object（适配器）
	7. Bridge（桥接）
	8. Composite（组合）
	9. Decorator（装饰）
	10. Facade（外观）
	11. Flyweight（享元）
	12. Proxy（代理）
- 行为型
	13. Interpreter（解释器）
	14. Template Method（模板方法）
	15. Chain of Responsibility（责任链）
	16. Command（命令）
	17. Iterator（迭代器）
	18. Mediator（中介者）
	19. Memento（备忘录）
	20. Observer（观察者）
	21. State（状态）
	22. Strategy（策略）
	23. Visitor（访问者）
## 按意义分类
- 解耦型
	- 构建解耦
		- Factory Method
		- Abstract Factory
		- Builder
	- 调用解耦
		- Facade
		- Mediator
	- 其他功能的解耦
	  - Adapter
	  - Decorator
	  - Proxy
- 优化型
	- 内存优化
		- Singleton
		- Flyweight
	- 算力优化
		- Singleton
		- Prototype
	- 类型结构优化
		- Bridge
- 解决方案型
	- Adapter
	- Composite
	- Decorator
	- Proxy
	- Template Method
	- Chain of Responsibility
	- Iterator
	- Memento
	- Observer
	- State
	- Strategy
# 面向对象设计的七大原则
1. 单一职责原则（Single Responsibility Principle）
	- 每一个类应该专注于做一件事情
2. 里氏替换原则（Liskov Substitution Principle）
	- 在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型
3. 依赖倒置原则（Dependence Inversion Principle）
	- 实现尽量依赖抽象，不依赖具体实现
4. 接口隔离原则（Interface Segregation Principle）
	- 应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口
	- 当一个类实现的接口中有其不需要实现的方法, 则这个接口就需要被拆分成多个更细致的接口
5. 迪米特法则（Law Of Demeter）
	- 又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用
	- 尽量只出现直接朋友, 避免间接朋友
6. 开闭原则（Open Close Principle）
	- 面向扩展开放，面向修改关闭
	- 在扩展一个功能时, 尽量通过添加新的类来实现, 而不是修改已有的代码
7. 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）
	- 尽量使用合成/聚合达到复用，尽量少用继承, 即一个类中有另一个类的对象
## 面向对象的核心
- 分工明确, 自己只需要专注自己的事情
- 优点: 易扩展, 易维护
# 单例模式
- 饿汉式
	
	- 饿汉式在类加载时实例化, 类加载是天然的线程安全, 因此不用考虑过多的线程安全问题
- 懒汉式
	- 懒汉式的重要问题: 线程安全
	- DCL
		- DCL因为编译器优化和JVM底层内部模型原因, 偶尔会出错, 在实际开发时不常使用
		- *但是其解决线程安全问题的思想值得学习*
	- 静态内部类
		- 此方式兼备了并发高效调用, 以及延迟加载的优势
- 枚举
	- 通过枚举类可以实现饿汉式
	- 因为枚举类的特性, 其元素是天然的单例
- 对DCL单例模式的思考
	- 描述
		- DCL单例模式就是在同步代码块之前加了一个判断
		- 就是这判断让实例被创建之后的线程不执行同步代码块
		- 这样当实例被创建后的程序性能得到提升
		
	- 为什么可以在同步代码块之前加一个判断, 并且这个判断可以带来性能提升?
		- 因为同步代码块中的语句有一个明确的、不需要执行的时间段
		- 即该类的实例被创建之后的这一时间段
		- 也就是说, 当该实例被创建后, 就算是不执行这个同步代码块, 也不会有什么问题
		- 因此, 在这个同步代码块之前加一个判断, 这个判断就是为了判断是否到了上述时间段,
		- 如果到了, 那就不用执行这个同步代码块了
	
	- 将DCL单例模式泛化出来的模型

	  ```java
	  if (!到了不需要执行同步代码块的时间) {
	      同步代码块
	  }
	  ```
- 破解单例
	- 通过反射操作获得新的对象
		- 单例都是通过将构造器私有进而防止用户获得新的对象, 但是通过反射可以访问私有构造器
		- 可以通过在构造器中加判断的方法来防止此破解方法
	- 通过序列化和反序列化获得新的对象
		- 将一个对象序列化后再反序列, 得到的反序列的对象就会是一个新的对象
		- 可以通过定义`readResolve`方法来防止创建新对象
- 案例
	
	- Spring中bean的创建模式使用单例模式
# 工厂设计模式
- 意义
	- 将创建和调用解耦
	- 将创建的工作交给工厂来管理
- 简单工厂模式
	- 简单工厂模式又称静态工厂模式, 因为其创建产品的方法通常可以是静态方法
	- 简单工厂模式没有实现OCP原则, 即在添加新功能(新产品)时, 需要修改工厂的代码
- 工厂方法模式
	- 工厂方法模式实现了OCP原则
	- 每个产品都有一个工厂, 这些工厂都实现了一个工厂接口
	- 当有新的产品出现时, 只需要添加一个新的工厂就可以了
- 简单工厂模式 vs 工厂方法模式
	- 同
		- 两者都是在产品不是很复杂时使用, 当产品呈现出产品族的表征时(如一个产品接口下又有多个细分的子接口), 两者都显得无能为力
	- 异
		- 工厂方法模式实现了OCP原理
			- 虽然工厂方法模式实现了OCP原则, 但是其类的组织结构更加复杂, 客户端的使用也更加复杂
			- 因此在实际开发中更加倾向于使用简单工厂模式
- 抽象工厂模式
	- 抽象工厂模式通常在创建产品族时使用
	- 通常是一个产品族对应一个工厂, 这些工厂都会实现一个工厂接口
	- 类图
		- ![UoFOSA.jpg](https://s1.ax1x.com/2020/07/21/UoFOSA.jpg)
- 案例
	- MyBatis中的SqlSessionFactory
# 建造者模式
- 意义
	- 将创建和调用解耦
	- 将创建的工作交给建造者来管理
- 建造者 vs 工厂
	- 工厂通常生产的产品通常不需要装配, 而建造者生产的产品需要装配(零件装配成整体)
	- 建造者模式内部将制造和装配解耦, 制造由Builder管理, 装配由Director管理
	- 在使用建造者模式时, 通常会和工厂模式搭配使用
- 案例
	- JDK中的StringBuilder
# 原型模式
- 意义
	- 有时创建一个对象很耗时, 或者需要繁琐的数据准备, 就可以使用原型模式, 将一个已经创建好的对象直接克隆一份
- 原型模式在Java中的实现
	- Object类已经实现了一个clone方法, 但是一个对象要克隆就需要实现Cloneable接口
- 深拷贝和浅拷贝
	- Object类的clone方法是浅拷贝, 即只拷贝基本数据类型和String类型, 其他的类型只拷贝其引用
	- 深拷贝的实现
		- 手动get/set
		- 使用序列化和反序列化
- 案例
	- Spring中bean的创建可以使用原型模式
# 适配器模式
- 意义
	- 适配器会适配特定的被适配对象的某些功能, 将这些功能通过一些处理后转化为新的功能
- 案例
	- JDK中IO的转换流(如InputStreamReader和ObjectInputStream)
# 代理模式
- 意义
	- 让一端代码的目的更加明了, 即只专注某一个核心业务, 其他相对不重要的事情由代理完成
	- 代理模式是AOP的核心实现机制
- 核心角色
	- 抽象角色
		- 真实角色和代理角色都需要实现这一接口
	- 真实角色
	- 代理角色
- 应用场景
	- 安全代理
		- 屏蔽对真实角色的直接访问
	- 远程代理
		- 通过代理类处理远程方法调用(RMI)
	- 延迟加载
		- 先加载轻量级的代理对象, 在真正需要使用时才去加载真实对象
- 静态代理
	- 由程序员自己定义并实现的代理
- 动态代理
	- 由程序自己生成的代理
	- 可使用的技术
		- JDK自带的动态代理
		- javaassist
		- CGLIB
		- ASM
# 桥接模式
- 意义
	- 当一个类同时承担了两个或者多个维度的性质时, 就会造成类的个数膨胀的问题(如现在有3种类型的电脑, 4种电脑的品牌, 则需要定义的类就有12个)
	- 使用桥接模式可以解决这类问题
- 具体实现
	- 将其中一个或多个性质转化为类的属性
	- 如将电脑的品牌转化为电脑类的属性, 这样就只需要定义3个电脑类, 4个品牌类, 再让电脑类组合品牌类
# 组合模式
- 意义
	- 用于处理树形结构的类的构成
- 核心角色
	- 抽象构件
		- 定义了容器和叶子构件的共同点
	- 容器
		- 容器下面有子节点
	- 叶子
		- 叶子下面没有子节点
	- 类图
		- ![UH0nnH.png](https://s1.ax1x.com/2020/07/22/UH0nnH.png)
# 装饰器模式
- 意义
	- 装饰器会装饰特定的被装饰对象的某些功能, 从而增强或优化这些功能
- 装饰器的实现与静态代理的实现类似
- 案例
	- JDK中IO的装饰流(如BufferedInputStream)
# 外观模式
- 意义
	- 外观模式是封装思想的一种体现
- 使用场景
  - 为一个子系统提供一个门面类, 以对外提供外部感兴趣的数据和行为, 而不用暴露外部不需要的细节
- 类图
	- ![UHR8dU.png](https://s1.ax1x.com/2020/07/22/UHR8dU.png)
# 享元模式
- 意义
	- 将多个相同或相似的对象进行共享, 以便节省内存
	- 享元模式通常会与工厂模式一并使用
	- 如下棋时的棋子就有很多相似
- 内部状态和外部状态
	- 内部状态: 用于共享的属性 ,不能随环境改变
		- 如棋子的大小, 形状, 颜色
	- 外部状态: 不用于共享的属性, 会随环境改变
		- 如棋子的位置
	- 决定一个属性是内部状态还是外部状态需要根据实际判断, 若是重复率高的属性就可以考虑为内部状态
- 实现
	- 定义一个享元类, 用于存储内部状态
	- 定义一个(多个)外部状态类, 用于存储外部状态
	- 定义一个享元工厂, 根据需求产出享元类
		- 享元工厂的核心是其中的享元池(通常是一个Map)
		- 当客户需要的享元类已经存在时, 就在享元池中取出享元类并返回
		- 当客户需要的享元类不存在时, 就创建一个享元类, 将其放入享元池, 并返回
	- 类图
		- ![UHTur9.png](https://s1.ax1x.com/2020/07/22/UHTur9.png)
- 案例
	- 各种池(如线程池)
	- String的字面量
	- Integer的-127到127
- 单例, 池, 享元
  - 对于一个对象创建开销较大, 或者想避免多次创建的开销的解决方案, 就是使用单例
  - 而存储着多个同一类型的单例, 就是池(使用池的原因有二: 避免单例的线程不安全/不同的单例间有不同)
  - 享元则是对单例和池的推广, 即, 将以对象为单位推广至以内部状态为单位
# 责任链模式
- 描述
	- 将能够处理同一类请求的对象连成一条链, 所提交的请求沿着链传递, 链上的对象逐个判断能否有能力处理该请求, 能则处理, 不能则传递给链上的下一个对象
- 类图
	- ![ULlU3j.png](https://s1.ax1x.com/2020/07/23/ULlU3j.png)
- 案例
	- Servlet开发中的Filter
# 迭代器模式
- 描述
	- 又叫游标(cursor)模式, 提供一种可以遍历聚合对象(容器)的方式
- 实现
	- 因为迭代器通常需要频繁地访问聚合对象(容器), 所以迭代器通常会被定义为聚合对象的内部类, 并实现一个统一的迭代器接口
	- 然后让聚合对象提供一个方法获得迭代器
- 案例
	- JDK中的大多数容器都有提供迭代器
# 中介者模式
- 意义
	- 将各个同事对象的交互改为通过中介者间接交互, 以减少各个同时对象之间的耦合度
	- ![ULtJLd.png](https://s1.ax1x.com/2020/07/23/ULtJLd.png)
- 案例
	- MVC中的控制器就是中介者
# 策略模式
- 描述
	- 对于不同的请求采用不同的处理方法
	- 如一件商品对于新客户和老客户, 其最终价格可能会有不同的处理方法
- 案例
	- Servlet中的service方法会根据请求方式的不同(get/post)来调用不同的处理方法(doGet/doPost)
# 模板方法模式
- 描述
	- 对于一套流程, 其中的大部分的操作都是相同的, 只是其中有某个环节会根据情况的变化而变化, 这时可以使用模板方法模式
	- 这个待实现的方法被称为回调方法或者钩子方法
- 实现
	- 固定的步骤由父类(通常是抽象类)写好, 依环境而定的步骤延迟到子类中实现
- 案例
	- Servlet中重写service方法
	- Junit单元测试
# 状态模式
- 描述
	- 不同的状态对应不同的行为
	- 如酒店订房, 房间的状态(空闲, 已预订, 已入住)决定对房间的不同处理
- 案例
	- JDK多线程中线程的状态(新生, 就绪...)
# 观察者模式
- 描述
	- 观察者订阅并监听信息发送者, 当发送者发送信息后, 观察者就能获取到信息
- 通知观察者的方法
	- 推
		- 将信息以广播的方式发送给所有观察者, 观察者只能被动接受
	- 拉
		- 观察者自己决定什么时候获取内容, 以及需要获取什么内容
- 实现
	- 可以通过JDK提供的Observable和Observer类实现
- 案例
	- Servlet中的Listener
	- Tomcat中的Lifecycle
# 备忘录模式
- 描述
	- 当一个对象的数据改变时, 拷贝一份原来的状态, 以便出错时恢复到原来的状态
- 核心角色
	- 源发器
		- 需要使用备忘录模式的类
	- 备忘录
		- 存储源发器需要备份的数据
	- 负责人
		- 保存备忘录
- 案例
	- 各个软件中的历史记录
	- 数据库的回滚
# 命令模式
- 描述
	- 也叫动作(action)模式或者事务(transaction)模式
	- 命令的发出方不直接将命令直接交给命令的接收方, 而是将命令发给一个中间对象, 由这个中间对象将命令发给接收方
	- 中间对象可以对命令进行排队, 缓存, 日志记录等操作
- 案例
	- 数据库事务机制的底层实现使用的就是命令模式
# 解释器模式
- 描述
	- 用于描述如何构成一个简单的语言解释器
	- 主要用于对使用面向对象语言的编译器和解释器设计
	- 实际开发中应用很少
- 案例
	- EL表达式的处理
	- 正则表达式的处理
	- SQL语法的处理
	- 数学表达式的处理
# 访问者模式
- 描述
	- 访问者模式将数据结构和对数据结构的操作解耦, 使得增加对数据结构的操作不需要修改数据结构, 也不需要修改原有的操作, 而只需要增加新的访问者
	- <img src="https://s3.ax1x.com/2020/11/30/DRIa8K.png" alt="图示" style="zoom: 80%;" />
- 特点
  - 数据结构中的元素类型可以不同
  - 对于不同的Element, 访问的方式可由具体的Visitor决定, 还可由具体的Element决定
- 案例
	- XML文档解析器的设计
	- 编译器的设计