# 文件系统与存储

- 一个磁盘可有多个分区, 每个分区对应一个文件系统(Filesystem)

## 基于INODE的文件系统

### Ext2存储布局

- <img src="https://s3.ax1x.com/2021/02/15/y6kztO.png" alt="Ext2" style="zoom:50%;" />

- 将磁盘分为一个引导和多个块组(一个块组大小为512byte)
  - 一个块组由若干的块(Block)组成
- 组成一个块组的块
  - 超级块(Super Block): 记录此filesystem的整体信息, 包括inode/block的总量、使用量、剩余量, 以及文件系统的格式与相关信息等
    - 超级块在每个块组的开头都有一份拷贝(第一个块组必须有, 后面的块组可以没有)
  - 块组描述表: 记录了块组中各个区域的位置和大小, 如在这个块组中从哪里开始是INODE Table, 从哪里开始是Data Blocks, 空闲的INODE和Data Block还有多少个
  - 块位图(Block Bitmap): 描述整个块组中哪些数据块已用哪些数据块空闲
  - INODE位图(INODE Bitmap): 描述整个块组中哪些INODE已用哪些INODE空闲
  - INODE表(INODE Table): 存储一个块组中的所有INODE, 通常INODE表和INODE的大小都是固定的
  - 数据块(Data Block): 实际存储文件内容的块, 一个块组中通常有很多个数据块, 这些数据块在物理上是连在一起的空间, 称为Data Blocks
- INODE节点
  - 每个文件在磁盘上的位置都由一个INODE进行索引
  - INODE分为两部分: 常用元数据、具体文件数据的位置(数据块指针的集合)
    - 注: 这些数据块可能和INODE同属于一个块组也可能分属于不同的块组
  - 常用元数据记录的信息
    - 文件类型
    - 文件大小
    - 链接数
    - 文件权限
    - 拥有用户/组
    - 时间(创建、修改、访问时间)
  - INODE中数据块指针的组成
    - 12个直接指针
    - 1个间接指针
    - 1个二级指针
    - 1个三级指针
    - INODE中多级数据块指针的设计让文件系统支持存储大小更大的文件

### Ext4文件存储 -- 区段树(Extent)

- 在Ext2的INODE节点中, 需要一个个的记录文件占用的数据块的索引
- 但是对于大文件来说, 其占用的数据块可能是连续的
- Ext4的区段树就可以记录文件占用的连续数据块的起始块号和长度, 来减少INODE的大小

### 特殊文件

- 目录文件
  - 目录文件的内容是一个个的目录项
  - 一个目录项对应该目录下面的一个文件(或子目录文件)
  - 目录项的内容
    - 对应文件的INODE号
    - 目录项长度
    - 文件名长度
    - 文件名
  - 特殊目录项
    - 文件名为`.`的目录项代表当前目录
    - 文件名为`..`的目录项代表父目录
- 软链接(符号链接/快捷方式)文件
  - 软链接文件的内容是一个文件路径
- 硬链接
  - 硬链接不是文件, 硬链接是一个指向现有文件的目录项
  - 一个目录中的`.`和`..`就是硬链接
- 设备文件
  - 设备文件分为字符设备文件和块设备文件
  - 设备文件用于代表一个硬件设备, 常用作为程序在做系统调用时的参数
    - 如Linux卸载分区: `$ sudo umount /dev/sda1`, 其中sda1文件就是设备文件
  - 设备文件中的主要内容是设备的Major号和Minor号
    - Major号表示设备类型
    - Minor号表示设备编号
- FIFO文件
  - 即命名管道, 用于进程间通信
    - 程序向FIFO文件的读和写其实是在向一个内存中的空间进行读和写, 而不是磁盘中
  - FIFO文件可以让程序通过调用文件的API接口来方便地达到进程间通信的目的
- SOCK文件
  - UNIX域套接字, 用于进程间通信

## 基于Table的文件系统

### FAT存储布局

- <img src="https://s3.ax1x.com/2021/02/15/y687C9.png" alt="FAT" style="zoom:50%;" />
- 数据区: 数据区由一个个数据簇构成, 每个数据簇都有自己的簇号
  - 数据簇的大小统一, 可以被配置
- FAT(文件分配表): 一个文件的内容可能由多个数据簇串接组成. FAT记录了对于一个文件, 存储其数据的某个数据簇的下一个数据簇的簇号
  - 当某数据簇对应的下一个数据簇的簇号为FFFF时标志该数据簇是存储该文件的最后一个数据簇
  - FAT有两份(第二份用于备份), 且存储在磁盘分区的开头

- FAT存储布局的特点
  - 文件系统简单
  - FAT的访问需要从前向后遍历, 因此随机读取文件慢
- 一般的U盘使用FAT文件系统

### NTFS文件系统

- <img src="https://s3.ax1x.com/2021/02/15/y6JeL6.png" alt="NTFS" style="zoom:50%;" />
- MFT
  - MFT类似于数据库中的关系表, 其中每一行记录一个文件的信息(所有的文件都会记录)
  - MFT的前16条记录为保留记录, 记录了MFT、MFT镜像、日志文件等文件的信息
  - 在MFT的16条记录之后, 记录的就是其他文件的信息
- 文件记录中记录的文件信息
  - 文件信息头
  - 各种文件的属性, 常见属性包括:
    - 文件标准元数据(大小、创建时间等)
    - 文件名
    - 数据
    - 索引根
  - 文件记录尾
- NTFS对文件的分类
  - 非常驻文件(大文件/目录)
  - 常驻文件(小文件/目录)
    - 大小不超过MFT记录的最大值(1KB)
    - 常驻文件的内容可以内嵌在MFT中保存(直接将内容放在MFT对应的文件记录中)
  - 目录项
    - 包含文件名、文件ID(在MFT中的序号)

## 虚拟文件系统(VFS)

- 一般一个OS中会存在多个文件系统, 且文件系统的种类可能不同

- VFS(Virtual File System)

  - VFS是Linux中的机制, 在Windows中类似的机制称为Installable File System
  - VFS是一个中间层, 向上提供POSIX API, 向下对接不同的文件系统驱动
    - 即, 将下面不同的文件系统抽象成统一的INODE文件系统

- VFS读取文件流程

  1. 找到该文件对应的文件系统

  2. 调用该文件系统的读取接口

- 挂载(mount)
  - VFS最终向OS提供的文件目录组织是一棵树, 因此若VFS要对接多个文件系统, 则需要将多棵树变成一棵树
  - 挂载机制就是将一棵树的根节点(即一个目录文件)覆盖到VFS文件目录中的某个目录文件之上
    - 当访问原来被覆盖的那个目录时, 取而代之的是访问到挂载的那个根节点
    - 原来的那个目录在卸载掉根节点后, 又可以重新访问

## 宏内核(Linux)中的存储栈

- 应用层
  - 应用程序
- 内核层
  - 虚拟文件系统
    - 管理多个文件系统, 提供统一抽象
  - 文件系统
    - 可能有多个, 且种类不一
    - 建立在块抽象的基础上
  - 块抽象
    - 提供和管理块抽象
    - 块抽象是对硬件层存储的抽象
  - I/O调度
    - 将I/O请求进行合并和调度
  - 设备驱动
    - 负责与设备进行通信
- 硬件层
  - 可能有多块磁盘, 且种类不一
  - 硬件层可以被替换为一个文件(如虚拟机中的"硬件层"), 或者是多台设备(如Google的文件系统), 或者是其他的平台

## 文件系统的崩溃一致性

- 文件系统随时可能崩溃
  - 可能是OS出现BUG
  - 可能是因为断电
- 崩溃后可能出现的问题
  - 文件系统只将存储设备中的部分进行进行了修改, 剩余部分没有被修改

- 崩溃一致性的保障方法
  - 原子更新技术
    - 日志
    - 写时复制(Copy on Write)
  - Soft updates

### 日志

- 在对存储设备的内容进行修改前, 先将修改操作记录到日志中, 然后提交日志
- 提交日志后, 再对存储设备的内容进行修改
- 在修改完毕后, 删除日志

### 写时复制

- 将需要修改的数据块进行复制
- 在复制的数据块上进行数据的修改
- 数据块修改完毕后修改指针, 让其从指向原数据块改为指向新的数据块

# 设备管理

## 外设的分类

- 字符设备
  - 访问方式
    - 顺序访问, 每次读取一个字符
    - 调用驱动程序和设备直接交互
  - 如: LED、键盘、串口
- 块设备
  - 访问方式
    - 随机访问, 以块为单位进行读写
  - 如: 磁盘、闪存
- 网络设备
  - 访问方式
    - 面向格式化报文的收发
    - 在驱动层以上维护多种协议, 支持不同策略
  - 如: 网卡

## CPU与外设的数据交互

- 可编程I/O(Programmable I/O)
  - 通过CPU的in/out或load/store指令
  - 交互的数据量与消耗的CPU时钟周期成正比
  - 适合于简单小型的设备
- 直接内存访问(DMA)
  - 外设可直接访问总线
  - 外设可通过DMA与内存相互传输数据, 不需要CPU参与
  - 适合于高吞吐量I/O

- DMA的具体过程

  - <img src="https://s3.ax1x.com/2021/02/17/ygOckj.png" alt="DMA" style="zoom:50%;" />

  1. 驱动发送数据传输请求
  2. 外设初始化DMA传递
  3. 外设传递数据到DMA控制器
  4. DMA控制器将数据传输至内存
  5. DMA控制器向CPU发出中断, 通知CPU传输完成

### CPU中断处理

- <img src="https://s3.ax1x.com/2021/02/17/ygXbqS.png" alt="中断处理" style="zoom:50%;" />

- AArch64中断分类
  - IRQ(Interrupt Request)
    - 普通中断, 优先级低, 处理慢
  - FIQ(Fast Interrupt Request)
    - 一次只能有一个FIQ
    - 快速中断, 优先级高, 处理快
    - 常为可信任的中断源预留
  - SError(System Error)
    - 原因难以定位、较难处理的异常, 多由异步中止(Abort)导致
  - IRQ和FIQ连接CPU的不同针脚, 可在中断控制器(Interrupt Controller)中配置
- AArch64中多核CPU的中断处理
  - 由GIC(Generic Interrupt Controller)来决定将中断发送给哪个CPU核

## 将设备抽象为文件

- OS可以将设备细节和协议封装在接口的内部
- 进程可以复用文件的API来与设备交互

## 设备驱动

- 驱动(Driver)
  - 使OS和设备间能相互通信的特殊程序

- 宏内核的驱动
  - 驱动在内核态
  - 优点: 性能更好
  - 缺点: 容错性较差
- 微内核的驱动
  - 驱动在用户态
  - 优点: 可靠性好
  - 缺点: IPC需要较高开销

## 驱动模型

- 驱动模型的意义
  - 设备的更新速度越来越快, 驱动的代码量在快速增长
  - 驱动模型的出现可以简化驱动的开发

### Linux设备驱动抽象

- Device(设备)
  - 用于抽象系统中所有的硬件
  - 包括CPU和内存
- Bus(总线)
  - CPU连接Device的通道
  - 所有的Device都通过Bus相连
- Class(分类)
  - 具有相似功能或属性的设备集合
  - 类似于面向对象程序设计中的Class
  - 抽象出一套可以在多个设备之间共享的数据结构和接口
  - 从属于相同Class的设备驱动程序, 直接继承

# 系统虚拟化

- 系统虚拟化的应用场景
  - 云计算: 一台机器上可以租给多个用户, 每个用户都有一个独立的操作系统
  - 程序调试: 可随时修改虚拟硬件的状态, 或者全程录制虚拟机的状态, 方便DEBUG

## 计算机中不同层次的接口

- <img src="https://s3.ax1x.com/2021/02/17/y2MZYd.png" alt="Interface" style="zoom:50%;" />

- ISA(Instruction Set Architecture)层
  - 区分硬件和软件
  - 用户ISA
    - 用户态程序可以使用
  - 系统ISA
    - 只有内核态程序可以使用
- ABI(Application Binary Interface)层
  - 提供系统服务或硬件功能
  - 包括用户ISA和系统调用
  - 即使OS改变, 但只要ABI层保证不变, 应用程序就可以在不同的OS上运行
    - 如可以运行在Windows 7的大多数程序可以在Windows 10中运行
- API(Application Programming Interface)层

## 虚拟机和虚拟机监控器

- <img src="https://s3.ax1x.com/2021/02/17/y21q39.png" alt="VMM" style="zoom:50%;" />

- 虚拟机(Virtual Machine)
  - 模拟出来ISA上层部分

- 虚拟机监控器(Virtual Machine Monitor/Hypervisor)
  - 基于底层的ISA层, 向上层虚拟机暴露其所需要的ISA
  - 可同时运行多台虚拟机

## 虚拟机监控器的分类

### Type-1虚拟机监控器

- 直接运行在硬件之上
  - 充当操作系统的角色
  - 直接管理所有物理资源
    - 实现调度、内存管理、驱动等功能
- 优点
  - 性能损失少
- 如: Xen、VMWare ESX Server
- Type-1的虚拟机监控器一般用在企业中

### Type-2虚拟机监控器

- 依托于Host OS(主机操作系统)
  - 物理资源由Host OS管理
  - 虚拟机监控器以进程/内核模块的形态运行
- 优点
  - 易于实现和安装
  - VMM可以直接复用Host OS的大部分功能(如驱动程序、CPU调度)
- 如: QEMU/KVM、VMWare
- Type-2的虚拟机监控器一般用在个人电脑中

## 系统虚拟化的流程

1. VMM捕捉所有系统ISA并陷入(Trap)
2. 由具体指令实现相应虚拟化
   - 控制虚拟处理器行为
   - 控制虚拟内存行为
   - 控制虚拟设备行为
3. 回到虚拟机继续执行

## 系统虚拟化技术

- CPU虚拟化
  - 捕捉系统ISA
  - 控制虚拟CPU行为
- 内存虚拟化
  - 提供"假"物理内存的抽象
- 设备虚拟化
  - 提供虚拟的I/O设备

### 内存虚拟化

- 内存虚拟化的目标
  - 为虚拟机提供虚拟的物理地址空间
  - 隔离不同虚拟机的物理地址空间
- 三种地址
  - 客户虚拟地址(Guest Virtual Address, GVA)
    - 虚拟机内程序使用的虚拟地址
  - 客户物理地址(Guest Physical Address, GPA)
    - 虚拟机内使用的"假"物理地址
  - 主机物理地址(Host Physical Address, HPA)
    - 真实寻址的物理地址
    - GPA需要翻译成HPA才能访问
  - GPA和HPA由VMM管理
- 内存虚拟化的实现: 硬件虚拟化
  - Intel VT-x和ARM硬件虚拟化都有对应的内存虚拟化
    - Intel Extended Page Table(EPT)
    - ARM Stage-2 Page Table(第二阶段页表)
  - EPT和第二阶段页表的作用都是将GPA翻译成HPA(GVA到GPA的翻译由虚拟机自己完成)

### I/O虚拟化

- I/O虚拟化的目标
  - 为虚拟机提供虚拟的外部设备
    - 虚拟机正常使用设备
  - 隔离不同虚拟机对外部设备的直接访问
    - 实现I/O数据流和控制流的隔离
  - 提高物理设备的利用资源
    - 多个VM同时使用, 可以提高物理设备的资源利用率

- I/O虚拟化的实现
  - 设备虚拟
  - 半虚拟化
  - 设备直通

## 轻量级虚拟化

- 云服务变得越来越轻量
  - On-Premises(本地部署) -> IaaS(基础设施即服务) -> PaaS(平台即服务) -> CaaS(容器即服务) -> SaaS(软件即服务) -> FaaS(函数即服务) -> Serverless(无服务)
- Serverless
  - 只在请求来时, 新建服务器实例执行相关逻辑, 执行完毕后销毁服务器实例
  - 特点: 请求驱动、弹性伸缩、按量计费
- FaaS
  - FaaS通常与Serverless相结合
  - 特点: 无状态、运行时间短(通常在秒级)
  - 两个重要的性能指标: 启动时间(启动运行环境的时间)、运行密度(同一时间能够运行的函数数量)

### LXC(Linux Container)

- LXC是Linux基于容器的轻量级虚拟化方案
  - 由Linux内核提供资源隔离机制
  - <img src="https://s3.ax1x.com/2021/02/18/yWpuUf.png" alt="LXC" style="zoom:50%;" />
- LXC需要主要的隔离
  - 安全隔离: Linux namespace
  - 性能隔离: Linux cgroup