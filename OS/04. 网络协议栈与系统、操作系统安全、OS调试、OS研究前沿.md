# 网络协议栈与系统

## 网络协议栈的分层模型

- 应用层
  - 游戏进程或聊天进程等
- 传输层
  - `TCP或UDP协议:端口`
- 网络层
  - `IP协议:主机地址`
- 数据链路层
  - 网络设备驱动
- 物理层
  - 网络设备

## Linux网络驱动模型

- Linux网络驱动模型
  - <img src="https://s3.ax1x.com/2021/02/19/yfgOoV.png" alt="Linux Net" style="zoom:50%;" />
  - 图中的网络协议栈对上(对用户)提供Socket接口

- Linux收包过程
  - <img src="https://s3.ax1x.com/2021/02/19/yf2HpD.png" alt="Linux收包过程" style="zoom:50%;" />

## Linux网络协议栈面临的挑战

- 网络设备的速度越来越高
  - 内核协议栈逐渐成为高性能网络(万兆及以上)的性能瓶颈
- CPU朝着多核方向发展

- 中断处理
  - 大量网络包的到来导致频繁的硬件中断请求

- 上下文切换
  - 线程间的调度产生频繁的上下文切换开销
  - 锁竞争的开销严重: cacheline sharing
- 内存拷贝
  - 数据从网卡DMA传到内核缓冲区, 再从内核空间拷贝到用户空间
  - 占据Linux内核协议栈数据包整个处理流程的57.1%
- 内存管理
  - 内存页大小为4K, 对TLB要求更高

- 局部性失效
  - 接收数据包的CPU核与该数据包的目标程序所在的CPU核可能不是同一个: 数据包处理可能跨多核, 导致CPU缓存失效, 空间局部性差
  - 接收数据包的CPU核所在的NUMA节点与该数据包的目标程序所在的NUMA节点可能不是同一个: 存在跨NUMA内存访问, 性能影响更大

### 用户态协议栈: Intel DPDK

- DPDK(Data Plane Development Kit)可以提高Linux处理网络数据包的效率
- Linux User I/O
  - UIO能够拦截中断, 并设置中断回调行为, 可以直接在用户态处理中断
  - 利用UIO可以绕过Linux内核协议栈的处理, 直接在用户空间实现数据包的收发和处理
- DPDK特性
  - 抛弃中断, 使用轮询模式
    - 轮询模式驱动: Poll Mode Driver(PMD)
  - 使用大页(2MB)
    - 减少TLB的miss
  - 控制平面与数据平面相分离
    - 内核态负责"控制平面": 内核仅负责控制指令的处理
    - 用户态负责"数据平面": 将数据包处理、内存管理、处理器调度等任务转移到用户空间去完成, 有效避免了繁重的模式切换
  - 用多核编程替代多线程技术
  - CPU核尽量使用所在NUMA节点的内存
    - 避免跨NUMA内存访问

# 操作系统安全

## 安全是OS的重要功能和服务

- 系统中有许多需要保护的数据
- 系统中可能存在许多恶意应用
  - OS需要与这些恶意应用做斗争, 保护自己, 限制对方
- OS不可避免的存在漏洞
  - OS需要考虑自己在被完全攻破的情况下依然提供一定的保护

## OS安全的三个概念

- 可信计算基(Trusted Computing Base)
  - 为实现计算机系统安全保护的所有安全保护机制的集合
  - 包括软件、硬件、固件(硬件上的软件)
  - TCB越小越安全
- 攻击面(Attacking Surface)
  - 一个组件被其他组件攻击的所有方法的集合
  - 可能来自上层、同层、底层
- 防御纵深(Defence in-depth)
  - 为系统设置多道防线, 为防御增加冗余, 以进一步提高攻击难度

## OS安全的三个层次

### 基于OS的应用隔离与访问控制

- 威胁模型
  - OS是可信的, 能够正常执行且不受攻击
  - 应用程序可能是恶意的, 可能会窃取其他应用的数据
  - 应用可能存在BUG, 导致访问其他应用数据
- 应用隔离
  - 内存数据隔离: 依赖进程间不同的虚拟地址空间的隔离
  - 文件系统隔离: 文件系统是全局的, 需限制哪些应用不能访问哪些文件
    - OS提供对文件系统的访问控制机制

### OS对恶意应用的隔离与防御

- 威胁模型
  - OS存在BUG和安全漏洞
  - OS的运行过程依然可信
  - 恶意应用利用OS漏洞攻击、获取更高权限或直接窃取其他应用的数据
- OS防御
  - 防御常见的操作系统BUG/漏洞
  - 使用沙盒机制限制应用的运行

### OS不可信时对应用的保护

- 威胁模型
  - OS不可信, 有可能被攻击者完全控制
  - 恶意应用可能与OS串通发起攻击
- 基于更底层的应用保护
  - 基于Hypervisor的保护: 可信基更小
  - 基于硬件Enclave的保护: 硬件通常更可信

## 访问控制

- 访问控制
  - 按照访问实体的身份来限制其访问对象的一种机制
  - 为了实现对不同应用访问不同数据的权限控制
  - 包含"认证(Authentication)"和"授权(Authorization)"两个重要步骤
- 认证和授权
  - 认证: 确定发起请求的实体的身份
  - 授权: 确定实体确实拥有访问资源的权限

- 引用监视器(Reference Monitor)
  - 是实现访问控制的一种方式
  - 主体必须通过引用(reference)的方式间接访问对象
  - 引用监视器位于主体和对象之间, 进行检查
  - <img src="https://s3.ax1x.com/2021/02/20/y5ut2Q.png" alt="Reference Monitor" style="zoom:50%;" />

### 认证机制

- 知道什么(Something you know)
  - 如: 密码/口令、手势密码、某个问题的答案
- 有什么(Something you have)
  - 如: USB-key、密码器等
- 是什么(Something you are)
  - 如: 指纹、虹膜、步态、键盘输入习惯等属于人的一部分

### 授权机制

- 文件的权限
  
- 读、写、执行
  
- 权限矩阵

  - 对象与实体之间的关系

  - |        | 对象-1 | 对象-2  | ...  |
    | ------ | ------ | ------- | ---- |
    | 实体-1 | 读/写  | 读/执行 |      |
    | 实体-2 |        | 读/写   |      |
    | ...    |        |         |      |

- 权限矩阵的实现

  - 使用用户组的概念, 将用户分为三类
    - 文件拥有者、文件拥有组、其他用户
  - 每个文件需要9个bit来存储权限: 3种权限 * 3类用户

- 检查用户权限的时机

  - 每次操作文件时检查(包括读、写、打开)
    - 可保证检查的完备性, 但对性能影响较大
  - 仅在每次打开文件时检查
    - 引入fd, 作为其他操作的参数
    - 性能开销较小

- 最小特权级: SUID机制
  - 用户的一些指令的正确执行需要使用到root权限
    - 如passwd指令
  - 因此在执行这类指令(也就是文件)时, 会将用户的权限短暂地提升为root权限, 在指令执行完毕后就将root权限撤回
  - sticky位
    - 对于那些执行需要提权的指令, 将其对应文件的inode中添加一个sticky位, 以标志这些指令的执行需要提取
    - 这些拥有sticky位的指令也常常称为攻击者的目标

### 基于角色的访问控制(RBAC)

- 角色
  - 角色与权限直接相关
  - 用户通过拥有一个或多个角色间接地拥有权限
  - "用户-角色", 以及"角色-权限", 一般都是多对多的关系
- RBAC的优势
  - 设定角色与权限之间的关系比设定用户与权限之间的关系更直观
  - 可一次性地更新所有拥有该角色用户的权限, 提高了权限更新的效率
  - 角色与权限之间的关系比较稳定, 而用户和角色之间的关系变化相对频繁
    - 设计者负责设定权限与角色的关系(机制)
    - 管理者只需要配置用户属于哪些角色(策略)

### DAC与MAC

- 自主访问控制(DAC, Discretionary Access Control)
  - 指一个对象的拥有者有权限决定该对象是否可以被其他人访问
- 强制访问控制(MAC, Mandatory Access Control)
  - 什么数据能被谁访问, 完全由底层的系统决定

## OS内部安全

### OS漏洞分类的三个角度

- 漏洞类型
  - 指攻击所利用的漏洞类型
  - 包括: 栈/堆缓冲区溢出错误、整形溢出错误、空指针/指针计算错误、内存暴露错误、use-after-free错误、格式化字符串错误、竞争条件错误、参数检查错误、认证检查错误等
- 攻击模块
  - 指攻击所利用漏洞所在的内核模块
  - 包括: 调度模块、内存管理模块、通信模块、文件系统、设备驱动等
- 攻击效果
  - 指攻击的目的或攻击导致的结果
  - 包括: 提升权限、执行任意代码、内存篡改、窃取数据、拒绝服务、破坏硬件等

### Return-to-user(ret2usr)攻击

- 内核错误地运行了用户态的代码
  - 由于内核与应用程序共享同一个页表, 内核运行时可以任意访问用户态的虚拟地址空间
  - 内核可能执行位于用户态的代码
- 攻击者的常用方法
  - 先在用户态中初始加载一段恶意代码, 然后利用内核的某个漏洞, 修改内核中的某个函数指针指向这段恶意代码的地址
  - 也可以利用内核的栈溢出漏洞, 覆盖栈上的返回地址为恶意代码的地址, 使内核在执行ret指令时跳转到位于用户态的代码

### ret2usr攻击的防御方法

- 方法一: 仔细检查内核中的每个函数指针
  - 需对内核所有模块进行检查, 很难做到100%的覆盖率
- 方法二: 在陷入内核时修改页表, 将用户态所有的内存都标记为不可执行
  - 由于修改页表后必须要刷新TLB才能生效, 因此修改页表、刷新TLB, 以及后续运行触发TLB miss都会导致性能下降
  - 在返回用户态之前必须将页表恢复, 并再次刷掉TLB, 这样又会导致用户态执行时出现TLB miss, 因此对性能的影响非常大
- 方法三∶硬件保证CPU处于内核态时不得运行任何用户态的代码
  - 如Intel的SMEP(Supervisor Mode Execution Prevention)技术
  - 如ARM的PXN(Privileged eXecute-Never)

### Rootkit: 获取内核权限的恶意代码

- Rootkit是指以得到root权限为目的的恶意软件
  - Rootkit可以运行在用户态, 也可以运行在内核态
- 用户态的Rootkit
  - 可以将自己注入到某个具有root权限的进程中, 并接收来自攻击者的命令
- 内核态的Rootkit
  - 可以是hook某个内核中的关键函数, 从而在该函数被调用时触发运行
  - 可以是以内核线程的方式运行
  - 可以是修改内核中的系统调用表, 用恶意代码来替换掉正常的系统调用

## 侧信道与隐秘信道

- 隐秘信道(Covert Channel)

  - 原本无法直接通信的两方, 通过原本不被用于通信的机制进行数据传输

  - 常见的隐秘信道: 时间、功耗、电磁泄露、声音等

    > 例: 应用A如何通过隐秘信道将信息传输给应用B
    > 若A可播放声音，B可录音，则A把数据编码为声音发送给B
    > 若A可打开闪光灯，B可摄像，则A把数据编码为光的闪烁长短与频率发送给B若A可震动，B可访问运动传感器，则A把数据编码为震动频率发送给B
    > 若B可访问CPU温度，则A可长时间运行计算密集代码，CPU升温表示1，反之为0

- 侧信道
  
  - 信息在不经意间通过某种方式泄漏出来, 这种形式就是侧信道
- 侧信道与隐秘信道
  - 相同点
    - 两者都是通过类似的方式进行数据的传递
  - 不同点
    - 隐秘信道攻击: 双方是互相串通的, 其目的就是为了将信息从一方传给另一方
    - 侧信道攻击: 一方是攻击者, 另一方是被攻击者, 攻击者窃取被攻击者的数据

- *注: 侧信道与隐秘信道的区别在于信息来源的一方是否是有意泄漏信息, 而不在于信息传递的途径或方式, 因此后文不将这两种信道做区分*

### 缓存信道(Cache Channel)

- 利用缓存的状态推测执行的信息

  - 如: 在下面的代码中, 通过判断`func_a`还是`func_b`在CPU缓存中, 来判断i的值

  - ```c
    if (i == 0) func_a();
    else func_b();
    ```

- 判断CPU缓存状态的四种攻击方式

  - flush + reload
  - flush + flush
  - prime + probe
  - evict + time

#### flush + reload

- 攻击步骤
  1. 攻击进程首先将cache清空
     - 可通过不断访问其他内存来占满cache, 或直接通过flush将cache清空
  2. 等待目标进程执行
  3. 攻击进程访问共享内存中的某个变量, 并记录访问的时间
     - 若时间长, 则表示cache miss, 意味着目标进程没有访问过该变量
     - 若时间短, 则表示cache hit, 意味着目标进程访问过该变量
- 特点分析
  - 优点: 可以跨CPU核, 甚至跨多个CPU、噪音低
  - 缺点:攻击准备难度高, 需构造与目标进程完全相同的内存页才能与目标进程共享内存

#### flush + flush

- 基于缓存flush时间(如clflush)来推测数据在缓存中的状态
  1. 攻击进程首先将cache清空(flush)
  2. 等待目标进程执行
  3. 运行`clflush`再次清空不同的缓存区域
     1. 若时间较短说明缓存中无数据
     2. 时间较长则说明缓存中有数据, 目标进程曾访问对应的内存
- 特点分析
  - 优点: 只需清空缓存而不需实际访存, 因此具有一定的隐蔽性
  - 缺点: clflush对于有数据和无数据的时间差异不明显, 攻击精度不高, 且必须依赖CPU具有`clflush`这条指令

#### evict + reload

- 场景:CPU没有clflush指令
  1. 将关键数据所在的cache set都替换成攻击进程的数据
  2. 等待目标进程执行
  3. 访问cache set中的某个数据
     - 若时间很短, 则说明目标进程没有将该数据evict, 即没有访问过某个关键数据
     - 若时间很长, 则说明目标进程访问了某个关键数据
- 特点分析
  - 优点: 无需依赖flush指令
  - 缺点: 无法支持动态分配的内存、需要了解LLC(Last Level Cache)的eviction策略、cache必须是inclusive、无法很好地支持多CPU

#### prime + probe

- 攻击步骤
  1. 攻击进程用自己的数据将cache set填满(Prime)
  2. 等待目标进程执行
  3. 再次访问自己的数据
     - 若时间很短, 说明目标进程没有将该数据evict, 即没有访问过某个关键数据
     - 若时间很长, 则说明目标进程访问了某个关键数据
- 特点分析
  - 优点: 不需要共享内存、支持动态和静态分配的内存
  - 缺点: 噪音更多、需要考虑LLC的实现细节, 如组相连等、cache必须是inclusive、无法很好地支持多CPU、需要首先定位目标进程使用的cache set

### 侧信道攻击的防御

- 侧信道攻击很难被完全防御住, 根本原因在于共享
  - 当被攻击者在做了某个操作后, 对系统整体产生了影响
  - 这个影响能够被使用同样系统的攻击者发现, 那么就构成了一个最简单的侧信道: 发现影响和没发现影响(即做了操作和没做操作)
- 防御侧信道的根本方法: 不共享
  - 将攻击者和被攻击者运行在完全隔离的物理主机, 使其没有任何共享, 包括计算硬件、网络, 甚至空间(光、温度、声音)
- 更实际的方法是针对常见攻击进行防御

#### 常量时间(Constant Time)算法

- 算法的运行时间与输入无关

  - 无法通过运行时间得到与输入相关的任何信息
  - 代码执行没有分支跳转

- 常见的实现方法: cmov(Conditional Move)

- 例: 加法运算的时间比除法运算的时间快得多

  - ```c
    // 传统实现方法
    if (secret == 0) x = a + b;
    else x = a / b;
    
    // 常量时间实现方法
    v1 = a + b;
    v2 = a / b;
    cond = (secret == 0);
    x = cmov(cond, v1, v2); // cond为真时返回v1, 否则返回v2
    ```

- 缺点: 计算变得更慢

  - 需要做两份运算

#### 不经意随机访问内存(ORAM)

- ORAM将访存行为与程序执行过程解耦
  - 攻击者即使能够观察到所有的访存请求, 也无法反推出与程序执行相关的信息
- 最简单的实现: 定时、定量、定位的访问方式
  - 无论实际是否有访存需求, 均以固定周期, 访问固定位置, 每次访问固定的大小
  - 例: CPU顺序循环访问所有的有效内存区域, 程序按需获得真正想要访问的数据, 若还没访问到则等待, 若已经访问过了则等待下次循环
    - 类似上海和北京之间的高铁, 无论乘客人数如何身份如何, 都按照时刻表运行, 哪怕有时候位子没坐满也发车, 因此根据高铁的班次并不能反推出谁坐了高铁
- 缺点: ORAM会引入很大的额外负载
  - 产生大量的无效内存访问, 导致有效访存的吞吐率下降
  - 访存需要等待一定的时刻, 导致时延大幅度增加

## 不可信OS与Enclave

- 为什么要假设OS是恶意的
  - 系统的复杂性
    - 软件: 恶意软件, OS本身可能存在漏洞
    - 硬件: 外设越来越智能, 本身可能存在漏洞, 甚至是恶意构造
    - 环境: 云计算环境、loT设备, 面临这更复杂多变的
    - 人: 运维外包(如云计算等)导致接触计算机的人更复杂
  - 一种更简单的威胁模型
    - “除了应用，别的都不可信”
- OS对应用的攻击
  - 窃取应用的数据
    - 操作系统控制着页表, 可直接映射应用的内存并读取数据
  - 改变应用的执行
    - 操作系统控制着页表, 可直接在应用内部新映射一段恶意代码
    - 操作系统可任意改变程序的RIP, 劫持其执行流

### 硬件Enclave

- 不信任CPU以外的任何硬件
  - 包括内存(DRAM)、设备、网络
- 仅信任CPU
  - 包括cache、所有的计算逻辑
- Enclave(飞地)
  - 又称为可信执行环境(TEE, Trusted Execution Environment)
- 保护Enclave的方法
  - 基于隔离
    - 使操作系统没有权限访问用户的数据
  - 基于加密
    - 操作系统即使访问用户数据, 也无法解密
  - 基于隔离+加密
    - 隔离防御软件攻击, 加密防御硬件攻击

### 隔离的方法

- 基于预留的隔离(硬件)
  - 如: PRM(Processor Reserved Memory)
  - CPU预留一部分物理内存, 不提供给操作系统
- 基于页表的隔离(操作系统)
  - 如; 保证操作系统无法映射应用的物理内存页
  - 问题: 页表是由操作系统自己管理的
- 基于插桩的隔离(编译器)
  - 如: SFl ( Software Fault lsolation )
    - 在每次访存前插入边界检查, 性能损失较大
- 隔离的优点
  - 现有系统本来就需要隔离, 对逻辑影响较小
  - 基于硬件检查的隔离对性能的影响较小
- 隔离的缺点
  - 通常需要硬件的支持, 例如引入新的权限层
  - 很难保证隔离的完整性, 需要信任设计与实现
    - 如CPU通过页表实现的隔离, 对恶意设备来说无效

# OS调试

- 调试器
  - 作用: 帮助定位和修复程序的BUG, 帮助程序员理解程序行为
  - 基本功能
    - 中断程序运行并读取内部状态
    - 获取程序异常退出原因
    - 动态修改软件状态
    - 控制流追踪

## Linux GDB调试器

- Linux的对调试的支持: ptrace系统调用
- 调试关系的建立
  - 子进程通过PTRACE_TRACEME将调试权交给父进程
  - 调试器通过PTRACE_ATTACH调试指定pid的进程
- GDB捕捉异常信号流程
  1. GDB等待应用事件
  2. 被调试程序出现异常(如除0异常), 陷入内核, 产生SIGFPE signal, 通知GDB
  3. GDB通过PTRACE_GETSIGINFO命令获取signal, 通过PTRACE_GETREGS获取被调试进程RIP地址
  4. GDB通过PTRACE_CONT通知进程继续执行, 并注入SIGFPE signal
  5. 被调试程序无SIGFPE signal处理函数, 进程退出, 并将退出通知告知GDB
  6. GDB通过waitpid返回值获取退出原因

## OS调试器

- 调试OS的难点
  - 在调试中的OS难以给调试器提供支持
  - 硬件相关问题, 如外部设备、页表等
- 通过模拟器调试OS
  - 虚拟机: 完整模拟底层硬件, 在模拟器中提供GDB stub(远程GDB)
  - 用户态模拟: 例如User-mode Linux, 忽略硬件相关的实现, 使Linux内核以普通进程的方式运行
- 通过内核自身实现的调试器来调试OS
  - OS内核实现GDB stub, 如Linux的KGDB

## 测试

- 测试的目的: 验证程序功能正确性
  - 程序是否会崩溃
  - 功能是否与设计一致
- 操作系统测试的必要性
  - 作为基础设施, 操作系统的正确性和性能直接影响上层应用
- 基准测试
  - 确定程序在特定运行环境下的性能指标

- 兼容性测试
  - 测试在不同硬件环境下的兼容性
  - 测试向上能否兼容应用
    - 向后兼容性: OS开发迭代后仍能运行较老的应用
- 稳定性测试
  - 压力测试
    - 压榨处理器、内存、IO等资源至极限
    - 频繁进行系统调用
    - 长时间测试(长稳测试)
  - 提高测试时的代码覆盖率
    - 未测试代码出现异常概率更高
- 性能测试

# OS研究前沿

- 操作系统是一个持续发展的领域
  - 操作系统的研究持续火热, 如今是系统研究"最好的时代"
- 操作系统研究受到上层应用和底层硬件双重驱动
  - 互联网、网络搜索、大数据、人工智能、智能驾驶、云计算等
  - 持久性内存、GPU、智能网卡、Al芯片、硬件Enclave等
- 两个核心问题
  - 如何为上层应用提供更快、更安全、更易用的接口
  - 如何为底层硬件建立高效、安全、高利用率的抽象

- 操作系统方向的重要学术会议
  - 顶级学术会议
    - soSP&OSDI: 交替在奇数年和偶数年召开, 许多内容进入OS教科书
  - 重要学术会议
    - ASPLOS: 偏重体系结构、编译与OS的结合
    - EuroSys: 基本在欧洲召开
    - USENIXATC: USENIX的技术年会, 议题较多, 偏工业界
  - 相关学术会议
    - USENIX NSDI: 网络系统方向
    - USENIX FAST: 文件系统与存储方向
    - HotOS: 专门讨论OS前沿的workshop, 奇数年召开
    - APSys: 在亚太地区召开的系统会议
    - ChinaSys: 在中国召开的系统会议
    - ...
- 操作系统的八个前沿研究领域
  - 异构操作系统
  - 智能网卡
  - 新的应用接口
  - 系统安全
  - 同步原语
  - 操作系统测试
  - 持久性内存
  - 形式化证明

## 异构OS

- 硬件发展的趋势: 多样化与异构化
  - 异构计算: CPU、GPU、FPGA、AI加速器等
  - 异构存储: DRAM、NVRAM、PIM等
  - 异构IO: 智能网卡、智能SSD等

- 为什么需要异构硬件?
  - 硬件能力很难再提升单个CPU核性能(摩尔定律的结束)
  - 上层应用对架构的性能提出了更高的要求
  - CPU无法满足Al计算、图形处理等场景的计算需求
    - Al加速器、GPU等异构计算和CPU并存
  - DRAM容量受限 -> NVM可以提供更大的内存容量
    - DRAM和NVM等多种内存并存
  - 数据中心和云需要更大的IO带宽和更低的时延
    - RDMA、以太网卡、智能IO设备等并存

- 异构硬件的涌现给OS带来了全新的挑战
  - 需要同时支持多种指令集(ISA)
    - 不同的计算单元可能使用不同的指令集
  - 内核/应用在跨总线的环境下的同步和通信
    - 异构硬件间通过多种总线连接, 无共享内存和缓存一致性
  - CPU提供OS服务容易成为系统性能瓶颈
    - 各种加速器等异构计算单元依赖于CPU提供OS服务
    - 以CPU为中心的OS服务: 需要多次拷贝, 性能开销大
    - 以加速器为中心的OS服务: 加速器不适合执行如网络协议栈等OS服务
  - ...

## 新的应用接口

- 极低时延应用对OS的新要求
  - 随着网络时延的降低, OS提供的服务和抽象成为了瓶颈
- 挑战-1: 内核软件栈臃肿
  - 内核软件栈涉及系统调用、内存管理、命名管理等开销, 成为了性能瓶颈
- 挑战-2: 内核抽象过于笨重
  - Linux内核代码逐年递增, 极大影响了虚拟机的启动效率
  - 虚拟机监控器(如Xen)在启动过程中引入了过大的软件开销
- 挑战-3: 应用缺乏对于调度的控制
  - 调度一定会进入内核，造成微秒级开销
    - 进程调度的开销是用户态线程调度开销的2倍
  - 内核缺乏应用语义, 可能无法做出最好的调度决策
- 小结: 设计新型操作系统的关键词
  - 放权
    - 将内核从应用的关键路径上移除, 绕开臃肿的软件栈
    - 将更多功能(如调度)交由应用完成, 减少进入内核的次数
  - 裁剪
    - 只保留内核抽象的必需功能, 最小化抽象带来的开销

## 智能网卡

- 摩尔定律逐渐失效
  - 处理器频率和核数难以大幅度提升
  - 网卡速度稳步提升: 处理器速度难以跟随网络速度进一步提升智能网卡的方案
- 允许将一部分软件功能卸载至智能网卡之中
  - 卸载的软件可直接处理网络数据, 减少与Host处理器交互