# 概念设计

## E-R图

- E-R模型用于数据库设计(如何存储/组织数据)

### 实体(Entity)

- 实体
  - 实体是客观存在的对象
    - 如人
  - 实体具有属性
    - 如人的姓名, 性别
- 实体集
  - 实体集是相同类型的实体的集合
  - 如人的集合

- 属性的类别
  - 简单属性与复合属性
    - 简单属性不可拆分(如一个人的年龄)
    - 复合属性可以拆分(如一个人的姓名可以拆分为姓和名)
  - 单值属性与多值属性
    - 一个实体的单值属性只有一个值(如一个人的身份证号)
    - 一个实体的多值属性可以有多个值(如一个人的银行卡号可以有多个)
  - 派生属性与基属性
    - 派生属性可以通过其他属性获得(如一个人的年龄可以通过出生日期获得)
    - 基属性不可以通过其他属性获得(如一个人的籍贯)

### 联系(Relationship)

- 联系
  - *联系(Relationship)与关系表中的关系(Relation)是不同的概念*
  - 联系指一个或多个实体之间的相互关联(如父亲和儿子之间存在父子关系)
  
- 联系也可以是一个实体集中, 不同实体时间的联系(如一个公司的员工中不同的员工之间可能存在上下属关系)
  
- 联系集

  - 联系集是一个或多个实体集中的实体的联系的集合

  - 自环联系集(recursive relationship set)

    - 只涉及一个实体集的联系集

  - 联系集的数学定义

    $$
    \{(e_1,e_2,\cdots,e_n)|e_1\in E_1,e_2\in E_2,\cdots,e_n\in E_n\}
    $$

    - 其中$(e_1,e_2,\cdots,e_n)$是一个联系, $E_i$是实体集

- 联系集的度
  - 这个联系集所涉及的实体集的个数为这个联系集的度
  - 大多联系集的度都为2, 一般度 >= 2的联系集也可以转化为度为2的联系集
  - n元联系集 = 度为n的联系集
  
- 映射基数
  - 映射基数表达一个实体通过特定联系集能够与其他实体关联的个数
  - 映射基数通常在二元联系集中进行描述
  - 二元联系集的映射基数有以下几种情况: 
    - 一对一(1: 1), 一对多(1: n), 多对一(n: 1), 多对多(n: m)
  
- 全参与和部分参与
  - 全参与和部分参与用于描述一个联系集所涉及的实体集中的某一个实体集
  - 全参与: 这个实体集中的所有实体都参与到了这个联系集当中
  - 部分参与: 这个实体集中可以有实体不参与到这个联系集当中
  
- 弱实体集

  - 在二元联系中, 若一个实体集离开另一个实体集就无法存在, 则这个实体集为弱实体集
  - 如: 课程章节离开课程就无法存在(存在没有意义)

### E-R图的画法

- 基本E-R图

  - 分成两部分的矩形代表实体集
    - 有阴影的第一部分包含实体集的名字
    - 第二部分包含实体集中所有属性的名字, 构成主码的属性以下划线标明
  - 菱形代表联系集
  - 线段将实体集连接到联系集
  - <img src="https://s1.ax1x.com/2020/10/14/05zunI.png" alt="基本E-R图" style="zoom:50%;" />
- 各种属性的表示
  - <img src="https://s1.ax1x.com/2020/10/14/05zvUf.png" alt="各种属性的表示" style="zoom:50%;" />
- 虚线将联系集属性连接到联系集
  - <img src="https://s1.ax1x.com/2020/10/14/0IpAQH.png" alt="属性连接到联系集" style="zoom:50%;" />

- 自环联系集
  - <img src="https://s1.ax1x.com/2020/10/14/0IpI6H.png" alt="自环联系集" style="zoom:50%;" />

- 单箭头表示一方, 无箭头表示多方
  - <img src="https://s1.ax1x.com/2020/10/14/0I9SXj.png" alt="one to many" style="zoom:50%;" />
- 双线显示实体在联系集中的参与度
  - <img src="https://s1.ax1x.com/2020/10/14/0ICci6.png" alt="double" style="zoom:50%;" />
- 双菱形代表连接到弱实体集的标志性联系集
  - <img src="https://s1.ax1x.com/2020/10/14/0ICci6.png" alt="double" style="zoom:50%;" />

- 通过数字表示对应关系的上下限

  - <img src="https://s1.ax1x.com/2020/10/14/0IPCF0.png" alt="num" style="zoom:50%;" />

  - 其中两根线上面都有数字来描述对应实体集的关系上下限
  - `x..y`
    - `x`代表该方中任意一条记录是否必须参与联系集(0代表可以不参加, 1代表必须参加)
    - `y`代表对方中最多可以有多少条记录可以与该方中的任意一条记录产生联系(为*时代表对方是多方)

### 扩展的E-R特性

#### 特化/概化

- 特化
  - 高层实体集可以特化得到一些低层的实体集
  - 这些低层实体集可以继承高层实体集的所有属性以及参加的联系
  - 并且可以拥有自己的属性和联系
- 概化
  - 与特化对称, 从不同的低层实体集中可以概化(抽象出共有特征)得到高层实体集
- `is a`
  - 高层实体集与其特化得到的低层实体集之间的联系是`is a`的联系, 即`低层实体集 is a 高层实体集`
  - 如: student is a person
- 特化的E-R图
  - <img src="https://s1.ax1x.com/2020/10/15/0ovTiT.png" alt="specify" style="zoom:50%;" />

- 特化/概化的约束
  - 不相交
    - 一个实体只能属于一个低层实体集
    - 在E-R图中用`disjoint`标注
    - <img src="https://s1.ax1x.com/2020/10/15/0Tp77R.png" alt="disjoint" style="zoom: 67%;" />
  - 重叠
    - 若不用`disjoint`标注则默认为重叠
    - 即, 一个实体可以属于多个低层实体集
  - 全部特化/概化
    - 每个高层实体必须属于一个低层实体集
    - 在E-R图中将ISA三角上面的连线改为双线
    - <img src="https://s1.ax1x.com/2020/10/15/0T983T.png" alt="total specify" style="zoom:67%;" />
  - 部分特化/概化
    - ISA三角上面的连线为单线时默认为部分特化/概化

#### 聚集

- 应用场景

  - 在一个三元联系集中, 需要再在此基础上添加一个实体集, 再构成一个四元的关系集
  - <img src="https://s1.ax1x.com/2020/10/15/0TPllT.png" alt="3 plus 4" style="zoom:50%;" />

  - 这时的关系会显得十分复杂
  - 可将该三元关系集看做是一个实体集, 这个实体集再与新添加的实体集联系, 可以简化这种复杂的联系
  - <img src="https://s1.ax1x.com/2020/10/15/0TipB4.png" alt="group" style="zoom:50%;" />

### E-R设计决策

- 用属性还是实体集来表示现实中的对象
  - 若业务仅关注该对象的标示, 则可作为属性
    - 如: 只关注一个用户的手机号
  - 若业务还需要关注该对象的其他信息, 可作为实体集
    - 如: 不仅关注一个用户的手机号, 还关注这个用户所用的手机的型号等信息
- 用实体集还是联系集
  - 在一个联系集中当一个实体集中的一条记录和另一个实体集中的一条记录可能有多次联系时, 考虑将联系集改为实体集, 这个实体集再与原来的实体集建立联系
  - <img src="https://s1.ax1x.com/2020/10/15/0TmBcR.png" alt="例" style="zoom:50%;" />

- 用属性还是用联系集

## 数据流图

- 数据流图(Data Flow Diagram, DFD)的作用
  - 以图形的方式描绘数据在系统中流动和处理的过程
- 数据流图与流程图的区别
  - 数据流图是从数据的角度来描述系统的, 而流程图则是从对数据加工的角度来描述系统的
  - 数据流图中的箭头是数据流, 而流程图中的箭头则是控制流
  - 数据流图适合于宏观地分析业务概况, 而程序流程图只适合于描述系统中某个加工的执行细节
- 符号
  - <img src="https://s3.ax1x.com/2020/12/03/DT7szQ.png" alt="element" style="zoom:50%;" />

### 高至低分解

- 高至低分解用于展示更多细节
- 每一层绘制一张数据流图, 一张比一张详细, 直到达到所需的细节层次为止
- <img src="https://s3.ax1x.com/2020/12/03/DTbh2F.png" alt="example" style="zoom: 33%;" />
- 顶层数据流图
  - 顶层图的作用在于表明被开发系统的范围以及它和周围环境的数据交换关系
  - 顶层数据流图只包含一个加工，用以表示被开发的系统，然后考虑该系统有哪些输入数据、输出数据流
- 下层数据流图
  - 将顶层流图的系统为若干子系统，决定每个子系统间的数据接口和活动关系

### 数据流图的规则

- 数据流不能由一个实体直接流向另一个实体
  - 数据流图的一大原则是数据不能自行转换成另一形态
  - 数据必须经由某程序的处理才可被分发至系统的某个部份
- 加工和处理的输入 >= 输出 >= 1
  - 常犯的错误有:
  - 黑洞(black hole) - 程序步骤可能有输入流，但没有输出流
  - 奇迹(miracle) - 一个程序步骤可能有输出流，但没有输入流
  - 灰洞(grey hole) - 程序步骤的输出可能大于其输入的总和

## 数据字典

- 数据字典的作用
  - 对数据流图中出现的所有被命名的图形元素在数据字典中作为一个词条加以定义，使每个图形元素的名称都有一个确切的解释

- 数据字典中涉及
  - 数据项
    - 通常对应关系表中的一个字段
    - 具有名称、说明、别名、数据类型、取值范围、取值含义等
  - 数据结构
    - 数据结构由数据项组成
    - 具有名称、含义、组成等
  - 数据流
    - 具有名称、含义、数据流来源、数据流去向、流量等
  - 数据存储
    - 具有名称、说明、流入的数据流、流出的数据流、数据量、存取方式等
  - 处理过程
    - 具有名称、说明、流入的数据流、流出的数据流、具体的处理等

# 逻辑设计

## E-R模型转为关系模型

- 每个实体集都对应一张表
- 实体集中属性的转换
  - 简单属性/基属性
    - 对应表中的一个字段
  - 复合属性
    - 应被拆分为多个基本属性, 并且分别对应一个字段
  - 多值属性
    - 多值属性需要额外新建一张表, 与实体集表成多对一的关系
- 弱实体集
  - 弱实体集对应一张表
  - 但是其表中的联合主键需要包含其依赖的实体集的表的主键

- 联系与表的对应

  - 每个联系集通常都对应一张表
  - 联系中涉及的实体的主键为表的字段
  - 表中还可以有其他字段, 这些字段通常是一个联系的附加信息(如产生一个联系的时间)

- 二元联系集表的主键的选择
  - 一对一时, 可选择任意实体集表的主键为联系集表的主键
  - 一对多/多对一时, 可选择多方的主键为联系集表的主键
  - 多对多时, 可将两个实体集表的主键作为联系集表的联合主键
- 关系表的简化
  - 在一对一, 一对多, 多对一时, 若关系表中没有这个关系的额外信息, 则可将这个关系表简化为一个属性
  - 在一对一时, 可以任意选择一方, 添加一个存储另一方的主键的字段
  - 在一对多, 多对一时, 在多方添加一个存储另一方的主键的字段
- 特化/概化
  - 方法1
    - 每个高层实体集都对应一张表
    - 每个低层实体集都对应一张表, 包括高层实体集的主键和自己的属性
    - 缺点: 获得低层实体的完整信息需要访问两张表
  - 方法2
    - 每个高层实体集都对应一张表
    - 每个低层实体集都对应一张表, 包括高层实体集的所有字段和自己的属性
    - 缺点: 低层实体集的表中存在重复数据(与高层实体集的表的数据相同)
      - 可以将高层实体集的表改为视图以减少数据的重复

## 范式

- 什么是范式(Normal Form)
  - 当关系表中的关系满足一定要求时, 称该关系表属于某种范式
- 不同的范式及其包含关系
  - $1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF$

### 1NF

- 原子的域
  - 如果一个域中的原子被认为是不可分割的, 则这个域就是原子的
  - 非原子域的例子
    - 复合属性, 多值属性, 复杂数据类型(如面向对象)
- 关系R ∈ 1NF的条件
  - R中所有属性的域都是原子的
- 当R不属于1NF时可能出现的问题
  - 容易导致数据冗余

### 函数依赖

- 函数依赖的定义
  - 假设关系模式R中有两个属性a和b
  - 若对于任意元组, a属性的值相同时b属性的值就相同
  - 则称属性a"函数决定"属性b, 或属性b"函数依赖于"属性a
  - 即, $a\rightarrow b$
- 函数依赖与主键
  - 函数依赖可以看做是主键的扩展
  - 对于主键, 其函数决定所有其他属性(因为当记录的主键相同时, 就表明这时同一条记录, 自然其他属性就相同)
  - 对于具有函数依赖的字段, 其只是决定一些属性的相同性, 而不是整条记录

- 平凡的函数依赖
  - 一般地, 若$\beta \subseteq\alpha$, 则$\alpha\rightarrow\beta$是平凡的
  - 反之为不平凡的
  - 如: $id\rightarrow id$和$(id, name)\rightarrow id$都是平凡的

- 函数依赖集
  - 一系列的函数依赖条件的集合称为函数依赖集
  - $F=\{函数依赖1, 函数依赖2,\cdots\}$
- 函数依赖集的闭包
  - 给定一个函数依赖集F, 存在其他函数依赖被F逻辑蕴含
    - 如: 若$A\rightarrow B$且$B\rightarrow C$, 则可得出$A\rightarrow C$
  - 被F逻辑蕴含的全体函数依赖的集合称为F的闭包, 用$F^+$表示
- 属性集的闭包
  - 给定一个属性集$\alpha$, 在函数依赖集F下由$\alpha$函数确定的所有属性的集合称为属性集$\alpha$的闭包, 记作$\alpha^+$
- 正则覆盖
  - 在F中, 一些函数依赖可能被已有的函数依赖逻辑蕴含
  - 将这些已经被蕴含的函数依赖省去, 可以得到一个最简洁的等价函数依赖集, 这个函数依赖集被记作$F_c$
- 无关属性
  - 对应函数依赖集F, 及其中的函数依赖$\alpha\rightarrow \beta$
  - 如果$A\in \alpha$并且F逻辑蕴含$F'=(F-\{\alpha\rightarrow\beta\})\cup\{(\alpha-A)\rightarrow\beta\}$, 则称A在$\alpha$中时无关的
  - 如果$A\in\beta$并且$F'=(F-\{\alpha\rightarrow\beta\})\cup\{\alpha\rightarrow(\beta-A)\}$逻辑蕴含F, 则称A在$\beta$中时无关的

- 使用函数依赖表示无损连接分解
  - 若R分解为R1和R2是无损连接分解, 则当且仅当下列依赖中的至少一个属于$F^+$
  - $R1\cap R2\rightarrow R1$
  - $R1\cap R2\rightarrow R2$
  - 即, R1和R2的共有的键能够至少函数决定R1中的所有键或者R2中的所有键
- 依赖保持
  - 由R分解出的模式R1, R2, ..., Rn中, 其对应的F1, F2, ..., Fn的集合的闭包与原R的F的闭包相等
  - 即$(F1\cup F2\cup\cdots\cup Fn)^+=F^+$
  - 则称该模式分解是依赖保持的

### 2NF

- R ∈ 2NF的条件
  - 若关系R ∈ 1NF, 且R中每一个非主属性完全函数依赖于任何一个候选码, 则R ∈ 2NF
- R不属于2NF的常见情况
  - 当R中的候选码由不止一个属性组成时, 一些非主属性完全函数依赖于部分主属性

### 3NF

- R ∈ 3NF的条件
  - R ∈ 1NF, 且R中不存在这样的主键X, 属性组Y及非主属性Z(Z不属于Y)使得X→Y，Y→Z，成立，Y→X不成立
- R不属于3NF的可能情况
  - 非主属性函数函数决定某些属性

### BCNF

- BCNF是对3NF的扩充
- R ∈ BCNF的条件
  - R ∈ 1NF, 且对于R中所有的函数依赖, 其决定因素中都包含主键
- 推论
  - 当R的候选码只有一个时, R ∈ 3NF 等价于 R ∈ BCNF
- R不属于BCNF的可能情况
  - 非主属性函数函数决定某些属性

### 多值依赖

### 4NF

### 5NF


## 模式分解

- 将一个模式分解为多个模式, 这多个模式用于分摊原模式的信息
  - 如: 将模式R(A, B, C, D, E)分解为R1(A, B, C)和R2(A, D, E)
- 模式分解后需要满足的条件
  - $R1\cup R2=R$
  - 无损连接分解: 分解后的表做自然连接时能够得到原表

# 数据库设计大致流程

1. 需求分析
   - 需要什么样的数据/应用程序和业务
2. 概念数据库设计

   - 使用E-R模型或者类似的高层次数据模型来描述数据

3. 逻辑数据库设计

   - 将概念设计转化为某个DBMS所支持的数据模型

4. 结构优化

   - 关系标准化, 检查冗余和相关的异常关系结构

5. 物理数据库设计

   - 索引, 集群和数据库调优

6. 创建初始化数据库&安全设计

   - 加载初始数据, 测试

   - 识别不同的用户及他们的角色(权限)

