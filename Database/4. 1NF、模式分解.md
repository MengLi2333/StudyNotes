# 1NF第一范式

- 原子的域
  - 如果一个域中的原子被认为是不可分割的, 则这个域就是原子的
  - 非原子域的例子
    - 复合属性, 多值属性, 复杂数据类型(如面向对象)
  - 非原子域容易导致数据冗余(重复)
- 1NF
  - 如果关系模式R中所有属性的域都是原子的, 则R属于第一范式

# 模式分解

- 一个属性较多的模式可能会出现以下问题

  - 数据冗余
    - 如: 在员工表中同时存入了员工的信息和其部门的信息, 则同一部门的不同员工的记录中就会出现重复的部门信息
  - 更新异常
    - 如: 在上述员工表中, 更新部门信息时漏掉了一些属于该部门的员工, 则导致部门信息不一致

  - 插入/删除异常
    - 如: 在上述员工表中, 插入一个部门未知的员工, 会导致其记录中出现大量的空值(部门信息为空)

- 模式分解
  - 将一个模式分解为多个模式, 这多个模式用于分摊原模式的信息
    - 如: 将模式R(A, B, C, D, E)分解为R1(A, B, C)和R2(A, D, E)
  - 模式分解后需要满足的条件
    - $R1\cup R2=R$
    - 无损连接分解: 分解后的表做自然连接时能够得到原表

## 函数依赖

- 函数依赖的定义
  - 假设关系模式R中有两个属性a和b
  - 若对于任意元组, a属性的值相同时b属性的值就相同
  - 则称属性a"函数决定"属性b, 或属性b"函数依赖于"属性a
  - 即, $a\rightarrow b$
- 函数依赖与主键
  - 函数依赖可以看做是主键的扩展
  - 对于主键, 其函数决定所有其他属性(因为当记录的主键相同时, 就表明这时同一条记录, 自然其他属性就相同)
  - 对于具有函数依赖的字段, 其只是决定一些属性的相同性, 而不是整条记录

- 平凡的函数依赖
  - 一般地, 若$\beta \subseteq\alpha$, 则$\alpha\rightarrow\beta$是平凡的
  - 反之为不平凡的
  - 如: $id\rightarrow id$和$(id, name)\rightarrow id$都是平凡的

- 函数依赖集
  - 一系列的函数依赖条件的集合称为函数依赖集
  - $F=\{函数依赖1, 函数依赖2,\cdots\}$
- 函数依赖集的闭包
  - 给定一个函数依赖集F, 存在其他函数依赖被F逻辑蕴含
    - 如: 若$A\rightarrow B$且$B\rightarrow C$, 则可得出$A\rightarrow C$
  - 被F逻辑蕴含的全体函数依赖的集合称为F的闭包, 用$F^+$表示
- 属性集的闭包
  - 给定一个属性集$\alpha$, 在函数依赖集F下由$\alpha$函数确定的所有属性的集合称为属性集$\alpha$的闭包, 记作$\alpha^+$
- 正则覆盖
  - 在F中, 一些函数依赖可能被已有的函数依赖逻辑蕴含
  - 将这些已经被蕴含的函数依赖省去, 可以得到一个最简洁的等价函数依赖集, 这个函数依赖集被记作$F_c$
- 无关属性
  - 对应函数依赖集F, 及其中的函数依赖$\alpha\rightarrow \beta$
  - 如果$A\in \alpha$并且F逻辑蕴含$F'=(F-\{\alpha\rightarrow\beta\})\cup\{(\alpha-A)\rightarrow\beta\}$, 则称A在$\alpha$中时无关的
  - 如果$A\in\beta$并且$F'=(F-\{\alpha\rightarrow\beta\})\cup\{\alpha\rightarrow(\beta-A)\}$逻辑蕴含F, 则称A在$\beta$中时无关的

- 使用函数依赖表示无损连接分解
  - 若R分解为R1和R2是无损连接分解, 则当且仅当下列依赖中的至少一个属于$F^+$
  - $R1\cap R2\rightarrow R1$
  - $R1\cap R2\rightarrow R2$
  - 即, R1和R2的共有的键能够至少函数决定R1中的所有键或者R2中的所有键
- 依赖保持
  - 由R分解出的模式R1, R2, ..., Rn中, 其对应的F1, F2, ..., Fn的集合的闭包与原R的F的闭包相等
  - 即$(F1\cup F2\cup\cdots\cup Fn)^+=F^+$
  - 则称该模式分解是依赖保持的