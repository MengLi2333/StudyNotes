# 简单排序

## BubbleSort

- 可stable

- 实现

  ```java
  // 从小到大排序, 排序时包括low和high
  static void bubbleSort(int[] arr, int low, int high) {
      int lastChgPos = 0;
      for (int i = high; i > low; i = lastChgPos) {
          for (int j = low; j < i; j++) {
              if (arr[j] > arr[j+1]) {
                  交换(arr[j], arr[j+1]);
                  lastChgPos = j;
              }
          }
      }
  }
  ```




- 效率: O(n^2)

## SelectionSort(不使用堆)

- 可stable

- 实现

  ```java
  void selectionSort(int[] arr) {
      for (int i = arr.length - 1; i >= 0; i--) {
          int maxVal = arr[0];
          int maxPos = 0;
          for (int j = i - 1; j > 1; j--) {
              if (arr[j] > maxVal) {
                  maxVal = arr[j];
                  maxPos = j;
              }
          }
          交换(arr[i], arr[maxPos]);
      }
  }
  ```



- 效率: O(n^2)

## InsertionSort

- 可stable

- 实现

  ```java
  void insertionSort(链表 head) {
      节点 p = head;
      for (; 不超过末尾(p); p = 得到后继(p)) {
          节点 q = 查找在p的前驱中大小不超过p的最小元素();
          将p插入q的后面();
      }
  }
  ```



## RadixSort

- 可stable

- 大致步骤

  - 建立一个编号0-9, 大小为10的桶数组
  - 根据每个数的个位将其放入桶数组中(如个位为0的放入编号为0的桶中)

  - 将桶数组中的元素依次取出, 再根据十位将其放入桶数组, 然后是百位, 千位...
  - 直到达到最大的数的最大位数

# 高级排序

## MergeSort

- 可stable

- 实现

  ```java
  void merge(int[] arr, int low, int mid, int high) {
      int[] tmp = new int[mid - low + 1]; // 前半段的拷贝
      System.arraycopy(arr, low, tmp, 0, mid - low + 1);
      int i = 0;
      int j = mid + 1;
      int k = low;
      while (i <= mid - low && j <= high) { // 当i和j都没到头
          if (tmp[i] <= arr[j]) {
              arr[k++] = tmp[i++];
          } else {
              arr[k++] = arr[j++];
          }
      }
      if (i > mid - low) {
          while (j <= high) {
              arr[k++] = arr[j++];
          }
      } else {
          while (i <= mid - low) {
              arr[k++] = tmp[i++];
          }
      }
  }
  void mergeSort(int[] arr, int low, int high) {
      if (low == high) {
          return;
      }
      int mid = low + ((high - low) >> 1);
      mergeSort(arr, low, mid);
      mergeSort(arr, mid + 1, high);
      merge(arr, low, mid, high);
  }
  ```



- 效率: O(nlogn)

## BucketSort

- 可stable
- 大致步骤
  - 建立一个桶数组(大小m), 将n个元素按梯度装入m个桶中
  - 分别对每个桶中的元素排序(其他高级排序)
  - 最后将每个桶中的元素合并
- 效率: O(n)

## CountingSort

- 可stable
- 适用场景
  - 线性序列中的元素的种类n << 线性序列的长度M
  - 即线性序列中有大量重复的元素
- 大致步骤
  - O(n)内遍历线性序列, 统计出每个种类的元素出现的次数, 并据此得到每个元素的积分(包括自己的出现次数, 以及比自己小的种类的所有出现次数)
  - 通过积分得到每个种类的元素出现在被排序序列中的范围: `[比自己小的最大种类的积分, 自己的积分)`
  - 通过上述范围得到有序序列
- 效率: O(n)

## HeapSort

- 堆排序——使用最大二叉堆的selectionSort选择排序
  - 选择排序将整个向量分为unsorted部分和sorted部分
  - 一般的选择排序的unsorted部分为普通向量, 因此在其中选择出最大值需要O(n)的时间
  - 而堆排序则是将unsorted部分换为最大二叉堆, 因此在其中选择出最大值只需要O(logn)时间
  - 因此堆排序的时间复杂度为O(nlogn)

## TournamentSort

- 大致步骤
  - 建立一颗胜者树, 选择出最终胜者, 放入数组中
  - 将上一次的最终胜者做标记, 沿着上一次最终胜者的竞赛路径重新比较(规定被标记的参赛者一定是败者), 选择出这一次的最终胜者, 放入数组中
  - 重复上一步骤, 直到胜者树中所有参赛者被标记
- 效率: O(nlogn)