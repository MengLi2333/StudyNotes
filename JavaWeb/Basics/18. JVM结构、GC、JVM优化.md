# 18. JVM结构、GC、JVM优化
- java -version

		>java -version
		java version "13.0.2" 2020-01-14
		Java(TM) SE Runtime Environment (build 13.0.2+8)
		Java HotSpot(TM) 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)
	- HotSpot: 热点探测: 当一个类(class文件)被频繁加载时, JVM会将class文件解析出来的native代码直接储存起来, 当下次这个类再被加载时, 直接将native代码取出来即可
	- Server/Client
		- JVM的两套机制
		- Client是为桌面端准备的, 分配的内存较少, 不需要处理大量的并发
		- Server是为服务器准备的, 分配的内存较多, 用于处理大量的并发
- JVM的基本结构
	- 类加载子系统与方法区
		- 类加载子系统负责从文件或网络中加载Class信息, 加载的类信息放在一块称为方法区的内存空间中
		- 除了类的信息, 方法区还会存储运行时常量池信息, 包括字符串字面量和数字常量(这部分信息时class文件中常量池部分的内存映射)
	- java堆: 在JVM被创建时创建, 所有对象的存储地点, 是java程序最主要的内存工作区域, 大小由JVM控制
	- 直接内存
		- Java的NIO库运行java程序使用直接内存
		- 直接内存是在java堆外的、直接向系统申请的内存(大小不受JVM控制)
		- 直接内存的访问速度优于java堆, 在读写频繁的场合可能会使用直接内存
		- java堆和字节内存的总和依旧受限于操作系统给出的最大内存
	- 垃圾回收系统: 垃圾回收系统会对方法区/java堆/直接内存的内存进行回收
	- java栈: 每个线程都有一个私有的栈, java栈在一个线程被创建时创建
	- 本地方法栈: 与java栈类似, 但是本地方法栈用于本地方法(native method)的调用(通常是C语言编写的)
	- PC(Program Counter)寄存器
		- 每个线程都有一个PC寄存器
		- 一个java线程时刻都在执行方法, 这个正在被执行的方法称为当前方法
		- 如果当前方法不是本地方法, PC寄存器就会执行当前正在被执行的指令, 如果是本地方法, PC寄存器的值就是undefined
		- PC寄存器更多是用于区分这个线程是否在执行本地方法
		- 执行引擎: java虚拟机的最核心组件之一, 负责执行JVM的字节码, 为了提高效率, 会使用即时编译(Just In Time)技术将方法编译成机器码再执行
- java堆结构图及分代
	- 分代
		- java堆被划分为年轻代/老年代/持久代
		- 年轻代又被划分为eden区和两个survivor区(比例8:1:1)
		- 在现在的JVM中, 持久代中的内容被放在方法区中, 也就没有持久代了
	- 分代垃圾回收
		- java堆中的年轻代采用一种垃圾回收器, 老年代采用一种垃圾回收器
- 垃圾回收常见算法
	- 引用计数算法
	- 复制算法
		- 年轻代中的两个survivor区就是复制算法的实现
		- 此算法有个缺点就是需要两倍的内存空间
	- 标记-清除算法(Mark-Sweep)
		- 从根节点遍历所有对象(被引用对象)并标记, 没有被标记的对象就是无用对象, 会被清除
		- 此算法的两个缺点
			- 会产生内存碎片
			- 清除时会暂停其他线程所有的工作(Stop The World)
	- 标记-整理算法(Mark-Compact)
		- 结合了标记-清除和复制两个算法的优点
		- 此算法分为两个阶段, 第一个阶段也是标记被遍历到的对象, 第二个阶段是遍历整个堆, 将未标记对象清除, 将存活对象压缩到堆中的一块, 按顺序排放
		- 避免了标记-清除的碎片问题, 同时也避免了复制算法的空间问题
- JVM垃圾收集器
	- 垃圾收集器与垃圾回收算法的关系: 垃圾收集器是垃圾回收算法的具体实现
	- ScavengeGC(次收集)(MinorGC)
		- ScavengeGC是发生在新生代(eden)的GC, 因为新生代java对象大多朝生夕死, 所以ScavengeGC非常频繁, 一般回收速度也比较快
		- 当eden空间不足以为对象分配内存时, 会触发ScavengeGC
	- FullGC(全收集)
		- 当old区满时, 会触发FullGC
		- FullGC一般比MinorGC慢10倍
	- 新生代垃圾收集器
		- 串行收集器 Serial
		- 并行收集器 ParNew
			- ParNew是Serial的多线程版, 是CMSGC的默认新生代收集器
			- ParNew只在多核CPU上比Serial优, 单核没多大区别
		- Parallel Scavenge收集器
			- Parallel Scavenge与ParNew类似, 都是使用复制算法, 都是并行多线程收集器
			- 与ParNew不同的是, Parallel Scavenge更关注系统吞吐量(吞吐量=运行用户代码时间/总时间)
	- 老年代收集器
		- Serial Old
			- Serial的Old版, 将Serial中的复制算法换成了标记-整理算法
			- 可以兼容所有新生代收集器
		- Parallel Old
			- Parallel的Old版, 算法与Parallel相同
			- Parallel Old只能与Parallel Scavenge兼容
		- CMS(Concurrent Mark Sweep)
			- 并发收集器
			- 可以和Serial/ParNew兼容
	- G1(Garbage-First)
		- 可以处理新生代和老年代的收集器, 不需要与其他收集器搭配
- JVM优化
	- jps.exe: 查看当前在JVM中运行的线程
	- jstat.exe
	- jinfo.exe
	- jmap.exe
	- jstack.exe
	- javap.exe
	- jcmd.exe: 几乎集合了jps.exe/jstat.exe/jinfo.exe/jmap.exe/jstack.exe的所有功能
	- jconsole.exe
	- jvisualvm
- JVM参数