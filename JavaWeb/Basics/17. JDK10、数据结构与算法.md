# 17. JDK10、数据结构与算法
## JDK10新特性
	- var: 局部变量类型推断
		- var是JDK10新增的保留类型, 不是关键字
		- var只针对局部变量
		- 当编译器无法推断变量类型时会报错, 如: `var a = null;`
	- 垃圾收集器
		- JDK10中采用的是G1(Garbage-First)收集器
		- G1收集器是一个全收集器(新生代/持久代/老年代都会收集)
	- JDK10的api新增73个新功能扩展
		- 在java.util.List/Set/Map下新增了一个静态方法: copyOf
			- 该方法按照容器的迭代顺序返回一个包含了给定元素的不可修改的列表/集合/映射
		- java.io.ByteArrayOutputStream下新增方法: toString(Charset)
			- ByteArrayOutputStream以前只有toString方法, 此方法是将流中的字节以UTF-8解码, 而新增方法可以指定字符集
		- java.io.Reader下新增方法: transferTo方法
			- 读取这个Reader中所有字符串, 并写入给指定的Writer
## 数据结构结构与算法
- 数据/数据项/数据元素/数据对象
	- 数据(data)
		- 数据是描述客观事物的数值、字符以及能输入机器且能被处理的各种符号集合
		- 含义广泛，如：数值、字符、声音、图像等一切可以输入计算机并能被处理的信息
	- 数据项(data item)
		- 数据项具有原子性, 是不可分割的最小单位
		- 如: 一个学生的姓名/性别/学号等都是数据项
	- 数据元素(data element)
		- 数据元素时数据的基本单位, 时数据集合的个体, 通常由若干个数据项组成, 在计算机程序中通常作为一个整体来处理
		- 如: 描述一位学生的完整信息的数据记录/空间中一个点的三维坐标
	- 数据对象(data object)
		- 数据对象是性质相同的数据元素的集合, 是数据的子集
		- 如: 一个学校的所有学生的集合/空间中所有点的集合
- 数据结构(data structure)
	- 数据结构的两个层面
		- 一个是在逻辑上的(不考虑具体实现的)数据的逻辑结构
		- 一个是在物理层面上的数据的存储结构
	- 数据结构 = 逻辑结构 + 存储结构 + 在存储结构上的运算/操作
- 数据逻辑结构
	- 集合结构
		- 与数学中的集合相似
		- 集合中的元素没有什么关系
		- 集合的三个特点: 确定性/唯一性/无序性
	- 线性结构
		- 四个基本特征
		1. 集合中有且只有一个"第一个元素"
		2. 集合中有且只有一个"最后一个元素"
		3. 除最后一个元素外, 其他数据元素有且只有一个直接"后继"
		4. 除第一个元素外, 其他数据元素有且只有一个直接"前驱"
	- 树状结构
		- 树状结构可以有多个直接"后继", 但只有一个直接"前驱"
	- 网状(图)结构
		- 网状结构可以有多个直接后继和多个直接前驱
- 数据存储结构
	- 顺序结构
		- 如: 数组
		- 优点: 节省空间(节点间的逻辑关系没有占用额外的空间)/查询效率高
		- 缺点: 增删效率低
	- 链式结构
		- 如: 双链表
		- 优点: 增删效率高
		- 缺点: 查询效率低
	- 索引结构
		- 如: 图书的目录
	- 散列结构
		- 如: 哈希表
- 时间复杂度/空间复杂度
	- 时间频度
	- 时间复杂度: T(n)
		- 最坏时间复杂度: O
		- 最好时间复杂度: Ω
		- 最好和最坏都是同一个阶: θ
	- 空间复杂度: S(n)
- 线性表
	- 顺序表: 如ArrayList(Vector已经过时)
	- 链表: 如LinkedList
- 栈(Stack)
	- 栈是运算受限的线性表(只能在栈的一端进行操作, 而不能在其他地方进行插入和删除操作)
		- 进行添加和删除操作的一端称为栈顶(top), 栈顶保存的元素称为栈顶元素
		- 另一端称为栈底(bottom)
	- 栈的操作
		- 入栈(push)
		- 出栈(pop)
		- 查看顶部元素(peek)
	- 栈的存储结构
		- 顺序栈
		- 链栈
- 队列(queue)
	- 队列也是运算受限的线性表(只能在队列的一端添加, 另一端删除)
		- 添加的一端叫队尾(rear)
		- 删除的一端叫队首(front)
	- 队列的操作
		- 入队(enqueue)
		- 出队(dequeue)
		- 获取队首元素(peek)
	- 队列的存储结构
		- 使用循环数组作为队列的存储结构
		- 链式队列
	- 双端队列(deck)
		- 前后两端都可以添加和删除
		- 输入/输出受限的双端队列
		- 只操作一端的双端队列(就和栈的概念一样了)
			- 这样的队列可以作为一种栈的实现(Java中的栈就是这样)
	- 栈的使用案例: 进制转换(先进的后出, 即倒置)
- Java中的栈和队列
	- Stack(过时, 因为继承了Vector)
	- Queue(队列)
	- Deque(双端队列, 建议用Deque替代Stack)
- 树
	- 树是由一个个节点组成的
	- 度
		- 节点的度: 这个节点有几个子树
		- 树的度: 这个数的节点的最大的度就是这个树的度
		- 根: 所有节点(不包括自己)的直接或非直接的父节点
		- 内部节点: 除了根以外的节点
		- 叶子/终端节点: 度为0的节点
	- 层次(level)
		- 根所在的层次是第一层
		- 根向下延伸一层, 节点的层次就+1
		- 树的深度(depth): 树中节点的最大深度
	- 父亲/儿子/兄弟
		- 父亲(parent): 节点的直接前驱
		- 儿子(child): 节点的直接后继
		- 兄弟(sibling): 该节点的直接父节点的其他直接子节点
- 有序树/无序树
	- 有序树: 数的每一层都是从左到右有次序的
	- 无序树: 树的每一层没有顺序, 即就算无序树的某一层的两个节点进行交换(带着子孙交换), 这棵树还是这棵树
- m叉树: 一个节点最多有m个子节点的树
- 森林: 互不相交的树的集合
	- 去掉一颗树的根, 这棵树就变成了森林
- 二叉树
	- 二叉树是有序的, 且一个父节点最多两个直接子节点
	- 一个父节点的左半边为左子树, 右半边为右子树
	- 满二叉树: 每一层都是满的
	- 完全二叉树: 除了最下层有空缺, 且空缺只能是从右边开始
	- 满二叉树一定是完全二叉树
	- 二叉树的存储结构
		- 顺序存储结构(不常用, 浪费空间)
		- 链式存储结构
			- 二叉链表(一个节点只有两个存储子节点的空间)
			- 三叉链表(一个节点不仅有两个存储子节点的空间, 还有一个存储父节点的空间)
	- 二叉树的遍历
		- 先根/先序(DLR): 根 左子树 右子树
		- 中根/中序(LDR): 左子树 根 右子树
		- 后根/后序(LRD): 左子树 右子树 根
		- 按层次遍历
- 图
	- 图由顶点和边构成(图的边还可以加权值和方向)
		- 图分为有向图和无向图(无向图其实是双向图)
	- 图的存储
		- 邻接矩阵(二维数组)
		- 邻接表(链式)
	- 图的遍历: BFS/DFS
	- 图的最短路径问题
		- 加权值的最短路径问题(无负权值): 迪科特斯拉算法
- 查找
	- 线性表查找
		- 顺序查找
		- 二分查找
	- 二叉查找/排序树(BST, Binary Search Tree)
		- BST的左子树上的元素都小于根, 右子树都大于根, 子树也是一颗BST
		- 对BST进行中序遍历, 则得到的序列是一个有序序列(从小到大)
		- 缺点: 
			- BST的添加较易, 删除和更新都很麻烦, 但每种情况都有对应的解决算法
			- 当给的数据已经具备一些有序性时, BST会退化成一个列表
	- 平衡二叉树(Self-balancing Binary Search Tree)
		- 一般说平衡二叉树就是指AVL树
		- 平衡二叉树的常见实现: AVL数/红黑树/替罪羊树/Treap/伸展树...
		- 平衡二叉树的左子树的深度和右子树的深度最多相差为1, 其子树也是如此
		- 平衡二叉树能够保证两边的子树相对平衡, 不会退化成列表
	- 红黑树(Red-Black Tree)
		- 每个节点不是红色就是黑色
		- 根节点是黑色
		- 每个叶子节点(NIL)是黑色(注意这里的叶子节点是指为空的叶子节点)
		- 如果一个节点是红色, 则其直接子节点必须是黑色
		- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点
	- 平衡树(Balance Tree)
		- 与BST不同, BT不一定只有两个子节点
	- B+树
		- B+树的前面的所有层都是索引, 真正的数据在最后一层
		- 数据的索引默认采用B+树
	- B*树
	- 哈希表
		- 哈希表有多重实现方式, 最常见的就是循序表+链表的方式
- 排序
	- 内部排序/外部排序
		- 内部排序: 所有数据都在内存中的排序
		- 外部排序: 数据量太大时, 内存无法容纳所有数据, 这时借用外部设备的排序叫做外部排序
	- 稳定排序/不稳定排序
		- 当序列中有相同的值时, 排序后, 原来在前面的还在前面, 在后面的还在后面, 这叫稳定排序
		- 反之叫做不稳定排序
	- 比较排序/非比较排序
		- 大部分排序都是需要比较的, 但是有一部分的排序不需要比较(如计数排序/基数排序)
	- 插入排序: 直接插入排序/希尔排序/折半插入排序
	- 选择排序: 选择排序/堆排序
	- 交换排序: 冒泡排序/快速排序
	- 归并排序: 归并排序
